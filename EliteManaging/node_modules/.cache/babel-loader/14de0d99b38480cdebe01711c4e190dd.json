{"ast":null,"code":"var alphabetByEncoding = {};\nvar alphabetByValue = new Array(64);\n\nfor (var i = 0, start = \"A\".charCodeAt(0), limit = \"Z\".charCodeAt(0); i + start <= limit; i++) {\n  var char = String.fromCharCode(i + start);\n  alphabetByEncoding[char] = i;\n  alphabetByValue[i] = char;\n}\n\nfor (var i = 0, start = \"a\".charCodeAt(0), limit = \"z\".charCodeAt(0); i + start <= limit; i++) {\n  var char = String.fromCharCode(i + start);\n  var index = i + 26;\n  alphabetByEncoding[char] = index;\n  alphabetByValue[index] = char;\n}\n\nfor (var i = 0; i < 10; i++) {\n  alphabetByEncoding[i.toString(10)] = i + 52;\n  var char = i.toString(10);\n  var index = i + 52;\n  alphabetByEncoding[char] = index;\n  alphabetByValue[index] = char;\n}\n\nalphabetByEncoding[\"+\"] = 62;\nalphabetByValue[62] = \"+\";\nalphabetByEncoding[\"/\"] = 63;\nalphabetByValue[63] = \"/\";\nvar bitsPerLetter = 6;\nvar bitsPerByte = 8;\nvar maxLetterValue = 63;\n/**\n * Converts a base-64 encoded string to a Uint8Array of bytes.\n *\n * @param input The base-64 encoded string\n *\n * @see https://tools.ietf.org/html/rfc4648#section-4\n */\n\nexport function fromBase64(input) {\n  var totalByteLength = input.length / 4 * 3;\n\n  if (input.substr(-2) === \"==\") {\n    totalByteLength -= 2;\n  } else if (input.substr(-1) === \"=\") {\n    totalByteLength--;\n  }\n\n  var out = new ArrayBuffer(totalByteLength);\n  var dataView = new DataView(out);\n\n  for (var i = 0; i < input.length; i += 4) {\n    var bits = 0;\n    var bitLength = 0;\n\n    for (var j = i, limit = i + 3; j <= limit; j++) {\n      if (input[j] !== \"=\") {\n        bits |= alphabetByEncoding[input[j]] << (limit - j) * bitsPerLetter;\n        bitLength += bitsPerLetter;\n      } else {\n        bits >>= bitsPerLetter;\n      }\n    }\n\n    var chunkOffset = i / 4 * 3;\n    bits >>= bitLength % bitsPerByte;\n    var byteLength = Math.floor(bitLength / bitsPerByte);\n\n    for (var k = 0; k < byteLength; k++) {\n      var offset = (byteLength - k - 1) * bitsPerByte;\n      dataView.setUint8(chunkOffset + k, (bits & 255 << offset) >> offset);\n    }\n  }\n\n  return new Uint8Array(out);\n}\n/**\n * Converts a Uint8Array of binary data to a base-64 encoded string.\n *\n * @param input The binary data to encode\n *\n * @see https://tools.ietf.org/html/rfc4648#section-4\n */\n\nexport function toBase64(input) {\n  var str = \"\";\n\n  for (var i = 0; i < input.length; i += 3) {\n    var bits = 0;\n    var bitLength = 0;\n\n    for (var j = i, limit = Math.min(i + 3, input.length); j < limit; j++) {\n      bits |= input[j] << (limit - j - 1) * bitsPerByte;\n      bitLength += bitsPerByte;\n    }\n\n    var bitClusterCount = Math.ceil(bitLength / bitsPerLetter);\n    bits <<= bitClusterCount * bitsPerLetter - bitLength;\n\n    for (var k = 1; k <= bitClusterCount; k++) {\n      var offset = (bitClusterCount - k) * bitsPerLetter;\n      str += alphabetByValue[(bits & maxLetterValue << offset) >> offset];\n    }\n\n    str += \"==\".slice(0, 4 - bitClusterCount);\n  }\n\n  return str;\n}","map":{"version":3,"mappings":"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","names":["alphabetByEncoding","alphabetByValue","Array","i","start","charCodeAt","limit","char","String","fromCharCode","index","toString","bitsPerLetter","bitsPerByte","maxLetterValue","fromBase64","input","totalByteLength","length","substr","out","ArrayBuffer","dataView","DataView","bits","bitLength","j","chunkOffset","byteLength","Math","floor","k","offset","setUint8","Uint8Array","toBase64","str","min","bitClusterCount","ceil","slice"],"sources":["C:\\Users\\jacob\\OneDrive\\College\\github\\resumeprojectsrepo\\resumeprojects\\EliteManaging\\node_modules\\@aws-sdk\\util-base64-browser\\src\\index.ts"],"sourcesContent":["const alphabetByEncoding: { [key: string]: number } = {};\nconst alphabetByValue: Array<string> = new Array(64);\n\nfor (let i = 0, start = \"A\".charCodeAt(0), limit = \"Z\".charCodeAt(0); i + start <= limit; i++) {\n  const char = String.fromCharCode(i + start);\n  alphabetByEncoding[char] = i;\n  alphabetByValue[i] = char;\n}\n\nfor (let i = 0, start = \"a\".charCodeAt(0), limit = \"z\".charCodeAt(0); i + start <= limit; i++) {\n  const char = String.fromCharCode(i + start);\n  const index = i + 26;\n  alphabetByEncoding[char] = index;\n  alphabetByValue[index] = char;\n}\n\nfor (let i = 0; i < 10; i++) {\n  alphabetByEncoding[i.toString(10)] = i + 52;\n  const char = i.toString(10);\n  const index = i + 52;\n  alphabetByEncoding[char] = index;\n  alphabetByValue[index] = char;\n}\n\nalphabetByEncoding[\"+\"] = 62;\nalphabetByValue[62] = \"+\";\nalphabetByEncoding[\"/\"] = 63;\nalphabetByValue[63] = \"/\";\n\nconst bitsPerLetter = 6;\nconst bitsPerByte = 8;\nconst maxLetterValue = 0b111111;\n\n/**\n * Converts a base-64 encoded string to a Uint8Array of bytes.\n *\n * @param input The base-64 encoded string\n *\n * @see https://tools.ietf.org/html/rfc4648#section-4\n */\nexport function fromBase64(input: string): Uint8Array {\n  let totalByteLength = (input.length / 4) * 3;\n  if (input.substr(-2) === \"==\") {\n    totalByteLength -= 2;\n  } else if (input.substr(-1) === \"=\") {\n    totalByteLength--;\n  }\n  const out = new ArrayBuffer(totalByteLength);\n  const dataView = new DataView(out);\n  for (let i = 0; i < input.length; i += 4) {\n    let bits = 0;\n    let bitLength = 0;\n    for (let j = i, limit = i + 3; j <= limit; j++) {\n      if (input[j] !== \"=\") {\n        bits |= alphabetByEncoding[input[j]] << ((limit - j) * bitsPerLetter);\n        bitLength += bitsPerLetter;\n      } else {\n        bits >>= bitsPerLetter;\n      }\n    }\n\n    const chunkOffset = (i / 4) * 3;\n    bits >>= bitLength % bitsPerByte;\n    const byteLength = Math.floor(bitLength / bitsPerByte);\n    for (let k = 0; k < byteLength; k++) {\n      const offset = (byteLength - k - 1) * bitsPerByte;\n      dataView.setUint8(chunkOffset + k, (bits & (255 << offset)) >> offset);\n    }\n  }\n\n  return new Uint8Array(out);\n}\n\n/**\n * Converts a Uint8Array of binary data to a base-64 encoded string.\n *\n * @param input The binary data to encode\n *\n * @see https://tools.ietf.org/html/rfc4648#section-4\n */\nexport function toBase64(input: Uint8Array): string {\n  let str = \"\";\n  for (let i = 0; i < input.length; i += 3) {\n    let bits = 0;\n    let bitLength = 0;\n    for (let j = i, limit = Math.min(i + 3, input.length); j < limit; j++) {\n      bits |= input[j] << ((limit - j - 1) * bitsPerByte);\n      bitLength += bitsPerByte;\n    }\n\n    const bitClusterCount = Math.ceil(bitLength / bitsPerLetter);\n    bits <<= bitClusterCount * bitsPerLetter - bitLength;\n    for (let k = 1; k <= bitClusterCount; k++) {\n      const offset = (bitClusterCount - k) * bitsPerLetter;\n      str += alphabetByValue[(bits & (maxLetterValue << offset)) >> offset];\n    }\n\n    str += \"==\".slice(0, 4 - bitClusterCount);\n  }\n\n  return str;\n}\n"]},"metadata":{},"sourceType":"module"}