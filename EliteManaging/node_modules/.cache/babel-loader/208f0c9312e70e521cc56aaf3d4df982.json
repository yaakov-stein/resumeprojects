{"ast":null,"code":"var __read = this && this.__read || function (o, n) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n  if (!m) return o;\n  var i = m.call(o),\n      r,\n      ar = [],\n      e;\n\n  try {\n    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n  } catch (error) {\n    e = {\n      error: error\n    };\n  } finally {\n    try {\n      if (r && !r.done && (m = i[\"return\"])) m.call(i);\n    } finally {\n      if (e) throw e.error;\n    }\n  }\n\n  return ar;\n};\n/*\n * Copyright 2017-2021 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\"). You may not use this file except in compliance with\n * the License. A copy of the License is located at\n *\n *     http://aws.amazon.com/apache2.0/\n *\n * or in the \"license\" file accompanying this file. This file is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR\n * CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions\n * and limitations under the License.\n */\n\n\nimport booleanClockwise from '@turf/boolean-clockwise';\nexport function validateCoordinates(lng, lat) {\n  if (!Number.isFinite(lng) || !Number.isFinite(lat)) {\n    throw new Error(\"Invalid coordinates: [\" + lng + \",\" + lat + \"]\");\n  }\n\n  if (lat < -90 || 90 < lat) {\n    throw new Error('Latitude must be between -90 and 90 degrees inclusive.');\n  } else if (lng < -180 || 180 < lng) {\n    throw new Error('Longitude must be between -180 and 180 degrees inclusive.');\n  }\n}\nexport function validateGeofenceId(geofenceId) {\n  var geofenceIdRegex = /^[-._\\p{L}\\p{N}]+$/iu; // Check if geofenceId is valid\n\n  if (!geofenceIdRegex.test(geofenceId)) {\n    throw new Error(\"Invalid geofenceId: '\" + geofenceId + \"' - IDs can only contain alphanumeric characters, hyphens, underscores and periods.\");\n  }\n}\nexport function validateLinearRing(linearRing, geofenceId) {\n  var errorPrefix = geofenceId ? geofenceId + \": \" : ''; // Validate LinearRing size, must be at least 4 points\n\n  if (linearRing.length < 4) {\n    throw new Error(errorPrefix + \"LinearRing must contain 4 or more coordinates.\");\n  } // Validate all coordinates are valid, error with which ones are bad\n\n\n  var badCoordinates = [];\n  linearRing.forEach(function (coordinates) {\n    try {\n      validateCoordinates(coordinates[0], coordinates[1]);\n    } catch (error) {\n      badCoordinates.push({\n        coordinates: coordinates,\n        error: error.message\n      });\n    }\n  });\n\n  if (badCoordinates.length > 0) {\n    throw new Error(errorPrefix + \"One or more of the coordinates in the Polygon LinearRing are not valid: \" + JSON.stringify(badCoordinates));\n  } // Validate first and last coordinates are the same\n\n\n  var _a = __read(linearRing[0], 2),\n      lngA = _a[0],\n      latA = _a[1];\n\n  var _b = __read(linearRing[linearRing.length - 1], 2),\n      lngB = _b[0],\n      latB = _b[1];\n\n  if (lngA !== lngB || latA !== latB) {\n    throw new Error(errorPrefix + \"LinearRing's first and last coordinates are not the same\");\n  }\n\n  if (booleanClockwise(linearRing)) {\n    throw new Error(errorPrefix + \"LinearRing coordinates must be wound counterclockwise\");\n  }\n}\nexport function validatePolygon(polygon, geofenceId) {\n  var errorPrefix = geofenceId ? geofenceId + \": \" : '';\n\n  if (!Array.isArray(polygon)) {\n    throw new Error(errorPrefix + \"Polygon is of incorrect structure. It should be an array of LinearRings\");\n  }\n\n  if (polygon.length < 1) {\n    throw new Error(errorPrefix + \"Polygon must have a single LinearRing array.\");\n  }\n\n  if (polygon.length > 1) {\n    throw new Error(errorPrefix + \"Polygon must have a single LinearRing array. Note: We do not currently support polygons with holes, multipolygons, polygons that are wound clockwise, or that cross the antimeridian.\");\n  }\n\n  var verticesCount = polygon.reduce(function (prev, linearRing) {\n    return prev + linearRing.length;\n  }, 0);\n\n  if (verticesCount > 1000) {\n    throw new Error(errorPrefix + \"Polygon has more than the maximum 1000 vertices.\");\n  }\n\n  polygon.forEach(function (linearRing) {\n    validateLinearRing(linearRing, geofenceId);\n  });\n}\nexport function validateGeofencesInput(geofences) {\n  var geofenceIds = {};\n  geofences.forEach(function (geofence) {\n    // verify all required properties are present\n    // Validate geofenceId exists\n    if (!geofence.geofenceId) {\n      throw new Error(\"Geofence '\" + geofence + \"' is missing geofenceId\");\n    }\n\n    var geofenceId = geofence.geofenceId;\n    validateGeofenceId(geofenceId); // Validate geofenceId is unique\n\n    if (geofenceIds[geofenceId]) {\n      throw new Error(\"Duplicate geofenceId: \" + geofenceId);\n    } else {\n      geofenceIds[geofenceId] = true;\n    } // Validate geometry exists\n\n\n    if (!geofence.geometry) {\n      throw new Error(\"Geofence '\" + geofenceId + \"' is missing geometry\");\n    }\n\n    var geometry = geofence.geometry; // Validate polygon exists\n\n    if (!geometry.polygon) {\n      throw new Error(\"Geofence '\" + geofenceId + \"' is missing geometry.polygon\");\n    }\n\n    var polygon = geometry.polygon; // Validate polygon length and structure\n\n    try {\n      validatePolygon(polygon, geofenceId);\n    } catch (error) {\n      if (error.message.includes('Polygon has more than the maximum 1000 vertices.')) {\n        throw new Error(\"Geofence '\" + geofenceId + \"' has more than the maximum of 1000 vertices\");\n      }\n    } // Validate LinearRing length, structure, and coordinates\n\n\n    var _a = __read(polygon, 1),\n        linearRing = _a[0];\n\n    validateLinearRing(linearRing, geofenceId);\n  });\n}","map":{"version":3,"mappings":"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","names":["booleanClockwise","validateCoordinates","lng","lat","Number","isFinite","Error","validateGeofenceId","geofenceId","geofenceIdRegex","test","validateLinearRing","linearRing","errorPrefix","length","badCoordinates","forEach","coordinates","error","push","message","JSON","stringify","lngA","latA","lngB","latB","validatePolygon","polygon","Array","isArray","verticesCount","reduce","prev","validateGeofencesInput","geofences","geofenceIds","geofence","geometry","includes"],"sources":["C:\\Users\\jacob\\OneDrive\\College\\github\\resumeprojectsrepo\\resumeprojects\\EliteManaging\\node_modules\\@aws-amplify\\geo\\src\\util.ts"],"sourcesContent":["/*\n * Copyright 2017-2021 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\"). You may not use this file except in compliance with\n * the License. A copy of the License is located at\n *\n *     http://aws.amazon.com/apache2.0/\n *\n * or in the \"license\" file accompanying this file. This file is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR\n * CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions\n * and limitations under the License.\n */\nimport booleanClockwise from '@turf/boolean-clockwise';\n\nimport {\n\tLongitude,\n\tLatitude,\n\tGeofenceId,\n\tGeofenceInput,\n\tGeofencePolygon,\n\tLinearRing,\n} from './types';\n\nexport function validateCoordinates(lng: Longitude, lat: Latitude): void {\n\tif (!Number.isFinite(lng) || !Number.isFinite(lat)) {\n\t\tthrow new Error(`Invalid coordinates: [${lng},${lat}]`);\n\t}\n\tif (lat < -90 || 90 < lat) {\n\t\tthrow new Error('Latitude must be between -90 and 90 degrees inclusive.');\n\t} else if (lng < -180 || 180 < lng) {\n\t\tthrow new Error(\n\t\t\t'Longitude must be between -180 and 180 degrees inclusive.'\n\t\t);\n\t}\n}\n\nexport function validateGeofenceId(geofenceId: GeofenceId): void {\n\tconst geofenceIdRegex = /^[-._\\p{L}\\p{N}]+$/iu;\n\n\t// Check if geofenceId is valid\n\tif (!geofenceIdRegex.test(geofenceId)) {\n\t\tthrow new Error(\n\t\t\t`Invalid geofenceId: '${geofenceId}' - IDs can only contain alphanumeric characters, hyphens, underscores and periods.`\n\t\t);\n\t}\n}\n\nexport function validateLinearRing(\n\tlinearRing: LinearRing,\n\tgeofenceId?: GeofenceId\n): void {\n\tconst errorPrefix = geofenceId ? `${geofenceId}: ` : '';\n\t// Validate LinearRing size, must be at least 4 points\n\tif (linearRing.length < 4) {\n\t\tthrow new Error(\n\t\t\t`${errorPrefix}LinearRing must contain 4 or more coordinates.`\n\t\t);\n\t}\n\n\t// Validate all coordinates are valid, error with which ones are bad\n\tconst badCoordinates = [];\n\tlinearRing.forEach(coordinates => {\n\t\ttry {\n\t\t\tvalidateCoordinates(coordinates[0], coordinates[1]);\n\t\t} catch (error) {\n\t\t\tbadCoordinates.push({ coordinates, error: error.message });\n\t\t}\n\t});\n\tif (badCoordinates.length > 0) {\n\t\tthrow new Error(\n\t\t\t`${errorPrefix}One or more of the coordinates in the Polygon LinearRing are not valid: ${JSON.stringify(\n\t\t\t\tbadCoordinates\n\t\t\t)}`\n\t\t);\n\t}\n\n\t// Validate first and last coordinates are the same\n\tconst [lngA, latA] = linearRing[0];\n\tconst [lngB, latB] = linearRing[linearRing.length - 1];\n\n\tif (lngA !== lngB || latA !== latB) {\n\t\tthrow new Error(\n\t\t\t`${errorPrefix}LinearRing's first and last coordinates are not the same`\n\t\t);\n\t}\n\n\tif (booleanClockwise(linearRing)) {\n\t\tthrow new Error(\n\t\t\t`${errorPrefix}LinearRing coordinates must be wound counterclockwise`\n\t\t);\n\t}\n}\n\nexport function validatePolygon(\n\tpolygon: GeofencePolygon,\n\tgeofenceId?: GeofenceId\n): void {\n\tconst errorPrefix = geofenceId ? `${geofenceId}: ` : '';\n\tif (!Array.isArray(polygon)) {\n\t\tthrow new Error(\n\t\t\t`${errorPrefix}Polygon is of incorrect structure. It should be an array of LinearRings`\n\t\t);\n\t}\n\tif (polygon.length < 1) {\n\t\tthrow new Error(\n\t\t\t`${errorPrefix}Polygon must have a single LinearRing array.`\n\t\t);\n\t}\n\n\tif (polygon.length > 1) {\n\t\tthrow new Error(\n\t\t\t`${errorPrefix}Polygon must have a single LinearRing array. Note: We do not currently support polygons with holes, multipolygons, polygons that are wound clockwise, or that cross the antimeridian.`\n\t\t);\n\t}\n\tconst verticesCount = polygon.reduce(\n\t\t(prev, linearRing) => prev + linearRing.length,\n\t\t0\n\t);\n\tif (verticesCount > 1000) {\n\t\tthrow new Error(\n\t\t\t`${errorPrefix}Polygon has more than the maximum 1000 vertices.`\n\t\t);\n\t}\n\tpolygon.forEach(linearRing => {\n\t\tvalidateLinearRing(linearRing, geofenceId);\n\t});\n}\n\nexport function validateGeofencesInput(geofences: GeofenceInput[]) {\n\tconst geofenceIds = {};\n\n\tgeofences.forEach((geofence: GeofenceInput) => {\n\t\t// verify all required properties are present\n\n\t\t// Validate geofenceId exists\n\t\tif (!geofence.geofenceId) {\n\t\t\tthrow new Error(`Geofence '${geofence}' is missing geofenceId`);\n\t\t}\n\t\tconst { geofenceId } = geofence;\n\t\tvalidateGeofenceId(geofenceId);\n\n\t\t// Validate geofenceId is unique\n\t\tif (geofenceIds[geofenceId]) {\n\t\t\tthrow new Error(`Duplicate geofenceId: ${geofenceId}`);\n\t\t} else {\n\t\t\tgeofenceIds[geofenceId] = true;\n\t\t}\n\n\t\t// Validate geometry exists\n\t\tif (!geofence.geometry) {\n\t\t\tthrow new Error(`Geofence '${geofenceId}' is missing geometry`);\n\t\t}\n\t\tconst { geometry } = geofence;\n\n\t\t// Validate polygon exists\n\t\tif (!geometry.polygon) {\n\t\t\tthrow new Error(`Geofence '${geofenceId}' is missing geometry.polygon`);\n\t\t}\n\t\tconst { polygon } = geometry;\n\n\t\t// Validate polygon length and structure\n\t\ttry {\n\t\t\tvalidatePolygon(polygon, geofenceId);\n\t\t} catch (error) {\n\t\t\tif (\n\t\t\t\terror.message.includes(\n\t\t\t\t\t'Polygon has more than the maximum 1000 vertices.'\n\t\t\t\t)\n\t\t\t) {\n\t\t\t\tthrow new Error(\n\t\t\t\t\t`Geofence '${geofenceId}' has more than the maximum of 1000 vertices`\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\n\t\t// Validate LinearRing length, structure, and coordinates\n\t\tconst [linearRing] = polygon;\n\t\tvalidateLinearRing(linearRing, geofenceId);\n\t});\n}\n"]},"metadata":{},"sourceType":"module"}