{"ast":null,"code":"import { __assign } from \"tslib\";\nimport { SENSITIVE_STRING } from \"@aws-sdk/smithy-client\";\nexport var ActiveContextTimeToLive;\n\n(function (ActiveContextTimeToLive) {\n  ActiveContextTimeToLive.filterSensitiveLog = function (obj) {\n    return __assign({}, obj);\n  };\n})(ActiveContextTimeToLive || (ActiveContextTimeToLive = {}));\n\nexport var ActiveContext;\n\n(function (ActiveContext) {\n  ActiveContext.filterSensitiveLog = function (obj) {\n    return __assign(__assign({}, obj), obj.parameters && {\n      parameters: SENSITIVE_STRING\n    });\n  };\n})(ActiveContext || (ActiveContext = {}));\n\nexport var BadRequestException;\n\n(function (BadRequestException) {\n  BadRequestException.filterSensitiveLog = function (obj) {\n    return __assign({}, obj);\n  };\n})(BadRequestException || (BadRequestException = {}));\n\nexport var ConflictException;\n\n(function (ConflictException) {\n  ConflictException.filterSensitiveLog = function (obj) {\n    return __assign({}, obj);\n  };\n})(ConflictException || (ConflictException = {}));\n\nexport var DeleteSessionRequest;\n\n(function (DeleteSessionRequest) {\n  DeleteSessionRequest.filterSensitiveLog = function (obj) {\n    return __assign({}, obj);\n  };\n})(DeleteSessionRequest || (DeleteSessionRequest = {}));\n\nexport var DeleteSessionResponse;\n\n(function (DeleteSessionResponse) {\n  DeleteSessionResponse.filterSensitiveLog = function (obj) {\n    return __assign({}, obj);\n  };\n})(DeleteSessionResponse || (DeleteSessionResponse = {}));\n\nexport var InternalFailureException;\n\n(function (InternalFailureException) {\n  InternalFailureException.filterSensitiveLog = function (obj) {\n    return __assign({}, obj);\n  };\n})(InternalFailureException || (InternalFailureException = {}));\n\nexport var LimitExceededException;\n\n(function (LimitExceededException) {\n  LimitExceededException.filterSensitiveLog = function (obj) {\n    return __assign({}, obj);\n  };\n})(LimitExceededException || (LimitExceededException = {}));\n\nexport var NotFoundException;\n\n(function (NotFoundException) {\n  NotFoundException.filterSensitiveLog = function (obj) {\n    return __assign({}, obj);\n  };\n})(NotFoundException || (NotFoundException = {}));\n\nexport var GetSessionRequest;\n\n(function (GetSessionRequest) {\n  GetSessionRequest.filterSensitiveLog = function (obj) {\n    return __assign({}, obj);\n  };\n})(GetSessionRequest || (GetSessionRequest = {}));\n\nexport var FulfillmentState;\n\n(function (FulfillmentState) {\n  FulfillmentState[\"FAILED\"] = \"Failed\";\n  FulfillmentState[\"FULFILLED\"] = \"Fulfilled\";\n  FulfillmentState[\"READY_FOR_FULFILLMENT\"] = \"ReadyForFulfillment\";\n})(FulfillmentState || (FulfillmentState = {}));\n\nexport var MessageFormatType;\n\n(function (MessageFormatType) {\n  MessageFormatType[\"COMPOSITE\"] = \"Composite\";\n  MessageFormatType[\"CUSTOM_PAYLOAD\"] = \"CustomPayload\";\n  MessageFormatType[\"PLAIN_TEXT\"] = \"PlainText\";\n  MessageFormatType[\"SSML\"] = \"SSML\";\n})(MessageFormatType || (MessageFormatType = {}));\n\nexport var DialogActionType;\n\n(function (DialogActionType) {\n  DialogActionType[\"CLOSE\"] = \"Close\";\n  DialogActionType[\"CONFIRM_INTENT\"] = \"ConfirmIntent\";\n  DialogActionType[\"DELEGATE\"] = \"Delegate\";\n  DialogActionType[\"ELICIT_INTENT\"] = \"ElicitIntent\";\n  DialogActionType[\"ELICIT_SLOT\"] = \"ElicitSlot\";\n})(DialogActionType || (DialogActionType = {}));\n\nexport var DialogAction;\n\n(function (DialogAction) {\n  DialogAction.filterSensitiveLog = function (obj) {\n    return __assign(__assign(__assign({}, obj), obj.slots && {\n      slots: SENSITIVE_STRING\n    }), obj.message && {\n      message: SENSITIVE_STRING\n    });\n  };\n})(DialogAction || (DialogAction = {}));\n\nexport var ConfirmationStatus;\n\n(function (ConfirmationStatus) {\n  ConfirmationStatus[\"CONFIRMED\"] = \"Confirmed\";\n  ConfirmationStatus[\"DENIED\"] = \"Denied\";\n  ConfirmationStatus[\"NONE\"] = \"None\";\n})(ConfirmationStatus || (ConfirmationStatus = {}));\n\nexport var IntentSummary;\n\n(function (IntentSummary) {\n  IntentSummary.filterSensitiveLog = function (obj) {\n    return __assign(__assign({}, obj), obj.slots && {\n      slots: SENSITIVE_STRING\n    });\n  };\n})(IntentSummary || (IntentSummary = {}));\n\nexport var GetSessionResponse;\n\n(function (GetSessionResponse) {\n  GetSessionResponse.filterSensitiveLog = function (obj) {\n    return __assign(__assign(__assign(__assign(__assign({}, obj), obj.recentIntentSummaryView && {\n      recentIntentSummaryView: obj.recentIntentSummaryView.map(function (item) {\n        return IntentSummary.filterSensitiveLog(item);\n      })\n    }), obj.sessionAttributes && {\n      sessionAttributes: SENSITIVE_STRING\n    }), obj.dialogAction && {\n      dialogAction: DialogAction.filterSensitiveLog(obj.dialogAction)\n    }), obj.activeContexts && {\n      activeContexts: SENSITIVE_STRING\n    });\n  };\n})(GetSessionResponse || (GetSessionResponse = {}));\n\nexport var BadGatewayException;\n\n(function (BadGatewayException) {\n  BadGatewayException.filterSensitiveLog = function (obj) {\n    return __assign({}, obj);\n  };\n})(BadGatewayException || (BadGatewayException = {}));\n\nexport var DependencyFailedException;\n\n(function (DependencyFailedException) {\n  DependencyFailedException.filterSensitiveLog = function (obj) {\n    return __assign({}, obj);\n  };\n})(DependencyFailedException || (DependencyFailedException = {}));\n\nexport var LoopDetectedException;\n\n(function (LoopDetectedException) {\n  LoopDetectedException.filterSensitiveLog = function (obj) {\n    return __assign({}, obj);\n  };\n})(LoopDetectedException || (LoopDetectedException = {}));\n\nexport var NotAcceptableException;\n\n(function (NotAcceptableException) {\n  NotAcceptableException.filterSensitiveLog = function (obj) {\n    return __assign({}, obj);\n  };\n})(NotAcceptableException || (NotAcceptableException = {}));\n\nexport var PostContentRequest;\n\n(function (PostContentRequest) {\n  PostContentRequest.filterSensitiveLog = function (obj) {\n    return __assign(__assign(__assign(__assign({}, obj), obj.sessionAttributes && {\n      sessionAttributes: SENSITIVE_STRING\n    }), obj.requestAttributes && {\n      requestAttributes: SENSITIVE_STRING\n    }), obj.activeContexts && {\n      activeContexts: SENSITIVE_STRING\n    });\n  };\n})(PostContentRequest || (PostContentRequest = {}));\n\nexport var DialogState;\n\n(function (DialogState) {\n  DialogState[\"CONFIRM_INTENT\"] = \"ConfirmIntent\";\n  DialogState[\"ELICIT_INTENT\"] = \"ElicitIntent\";\n  DialogState[\"ELICIT_SLOT\"] = \"ElicitSlot\";\n  DialogState[\"FAILED\"] = \"Failed\";\n  DialogState[\"FULFILLED\"] = \"Fulfilled\";\n  DialogState[\"READY_FOR_FULFILLMENT\"] = \"ReadyForFulfillment\";\n})(DialogState || (DialogState = {}));\n\nexport var PostContentResponse;\n\n(function (PostContentResponse) {\n  PostContentResponse.filterSensitiveLog = function (obj) {\n    return __assign(__assign(__assign({}, obj), obj.message && {\n      message: SENSITIVE_STRING\n    }), obj.activeContexts && {\n      activeContexts: SENSITIVE_STRING\n    });\n  };\n})(PostContentResponse || (PostContentResponse = {}));\n\nexport var RequestTimeoutException;\n\n(function (RequestTimeoutException) {\n  RequestTimeoutException.filterSensitiveLog = function (obj) {\n    return __assign({}, obj);\n  };\n})(RequestTimeoutException || (RequestTimeoutException = {}));\n\nexport var UnsupportedMediaTypeException;\n\n(function (UnsupportedMediaTypeException) {\n  UnsupportedMediaTypeException.filterSensitiveLog = function (obj) {\n    return __assign({}, obj);\n  };\n})(UnsupportedMediaTypeException || (UnsupportedMediaTypeException = {}));\n\nexport var PostTextRequest;\n\n(function (PostTextRequest) {\n  PostTextRequest.filterSensitiveLog = function (obj) {\n    return __assign(__assign(__assign(__assign(__assign({}, obj), obj.sessionAttributes && {\n      sessionAttributes: SENSITIVE_STRING\n    }), obj.requestAttributes && {\n      requestAttributes: SENSITIVE_STRING\n    }), obj.inputText && {\n      inputText: SENSITIVE_STRING\n    }), obj.activeContexts && {\n      activeContexts: SENSITIVE_STRING\n    });\n  };\n})(PostTextRequest || (PostTextRequest = {}));\n\nexport var IntentConfidence;\n\n(function (IntentConfidence) {\n  IntentConfidence.filterSensitiveLog = function (obj) {\n    return __assign({}, obj);\n  };\n})(IntentConfidence || (IntentConfidence = {}));\n\nexport var PredictedIntent;\n\n(function (PredictedIntent) {\n  PredictedIntent.filterSensitiveLog = function (obj) {\n    return __assign(__assign({}, obj), obj.slots && {\n      slots: SENSITIVE_STRING\n    });\n  };\n})(PredictedIntent || (PredictedIntent = {}));\n\nexport var ContentType;\n\n(function (ContentType) {\n  ContentType[\"GENERIC\"] = \"application/vnd.amazonaws.card.generic\";\n})(ContentType || (ContentType = {}));\n\nexport var Button;\n\n(function (Button) {\n  Button.filterSensitiveLog = function (obj) {\n    return __assign({}, obj);\n  };\n})(Button || (Button = {}));\n\nexport var GenericAttachment;\n\n(function (GenericAttachment) {\n  GenericAttachment.filterSensitiveLog = function (obj) {\n    return __assign({}, obj);\n  };\n})(GenericAttachment || (GenericAttachment = {}));\n\nexport var ResponseCard;\n\n(function (ResponseCard) {\n  ResponseCard.filterSensitiveLog = function (obj) {\n    return __assign({}, obj);\n  };\n})(ResponseCard || (ResponseCard = {}));\n\nexport var SentimentResponse;\n\n(function (SentimentResponse) {\n  SentimentResponse.filterSensitiveLog = function (obj) {\n    return __assign({}, obj);\n  };\n})(SentimentResponse || (SentimentResponse = {}));\n\nexport var PostTextResponse;\n\n(function (PostTextResponse) {\n  PostTextResponse.filterSensitiveLog = function (obj) {\n    return __assign(__assign(__assign(__assign(__assign(__assign({}, obj), obj.alternativeIntents && {\n      alternativeIntents: obj.alternativeIntents.map(function (item) {\n        return PredictedIntent.filterSensitiveLog(item);\n      })\n    }), obj.slots && {\n      slots: SENSITIVE_STRING\n    }), obj.sessionAttributes && {\n      sessionAttributes: SENSITIVE_STRING\n    }), obj.message && {\n      message: SENSITIVE_STRING\n    }), obj.activeContexts && {\n      activeContexts: SENSITIVE_STRING\n    });\n  };\n})(PostTextResponse || (PostTextResponse = {}));\n\nexport var PutSessionRequest;\n\n(function (PutSessionRequest) {\n  PutSessionRequest.filterSensitiveLog = function (obj) {\n    return __assign(__assign(__assign(__assign(__assign({}, obj), obj.sessionAttributes && {\n      sessionAttributes: SENSITIVE_STRING\n    }), obj.dialogAction && {\n      dialogAction: DialogAction.filterSensitiveLog(obj.dialogAction)\n    }), obj.recentIntentSummaryView && {\n      recentIntentSummaryView: obj.recentIntentSummaryView.map(function (item) {\n        return IntentSummary.filterSensitiveLog(item);\n      })\n    }), obj.activeContexts && {\n      activeContexts: SENSITIVE_STRING\n    });\n  };\n})(PutSessionRequest || (PutSessionRequest = {}));\n\nexport var PutSessionResponse;\n\n(function (PutSessionResponse) {\n  PutSessionResponse.filterSensitiveLog = function (obj) {\n    return __assign(__assign(__assign({}, obj), obj.message && {\n      message: SENSITIVE_STRING\n    }), obj.activeContexts && {\n      activeContexts: SENSITIVE_STRING\n    });\n  };\n})(PutSessionResponse || (PutSessionResponse = {}));","map":{"version":3,"mappings":"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","names":["SENSITIVE_STRING","ActiveContextTimeToLive","obj","ActiveContext","parameters","BadRequestException","ConflictException","DeleteSessionRequest","DeleteSessionResponse","InternalFailureException","LimitExceededException","NotFoundException","GetSessionRequest","FulfillmentState","MessageFormatType","DialogActionType","DialogAction","slots","message","ConfirmationStatus","IntentSummary","GetSessionResponse","recentIntentSummaryView","map","item","filterSensitiveLog","sessionAttributes","dialogAction","activeContexts","BadGatewayException","DependencyFailedException","LoopDetectedException","NotAcceptableException","PostContentRequest","requestAttributes","DialogState","PostContentResponse","RequestTimeoutException","UnsupportedMediaTypeException","PostTextRequest","inputText","IntentConfidence","PredictedIntent","ContentType","Button","GenericAttachment","ResponseCard","SentimentResponse","PostTextResponse","alternativeIntents","PutSessionRequest","PutSessionResponse"],"sources":["C:\\Users\\jacob\\OneDrive\\College\\github\\resumeprojectsrepo\\resumeprojects\\EliteManaging\\node_modules\\@aws-sdk\\client-lex-runtime-service\\models\\models_0.ts"],"sourcesContent":["import {\n  SENSITIVE_STRING,\n  LazyJsonString as __LazyJsonString,\n  SmithyException as __SmithyException,\n} from \"@aws-sdk/smithy-client\";\nimport { MetadataBearer as $MetadataBearer } from \"@aws-sdk/types\";\nimport { Readable } from \"stream\";\n\n/**\n * <p>The length of time or number of turns that a context remains active.</p>\n */\nexport interface ActiveContextTimeToLive {\n  /**\n   * <p>The number of seconds that the context should be active after it is first sent in a\n   *         <code>PostContent</code> or <code>PostText</code> response. You can set the value between 5\n   *       and 86,400 seconds (24 hours).</p>\n   */\n  timeToLiveInSeconds?: number;\n\n  /**\n   * <p>The number of conversation turns that the context should be active. A conversation turn is\n   *       one <code>PostContent</code> or <code>PostText</code> request and the corresponding response\n   *       from Amazon Lex.</p>\n   */\n  turnsToLive?: number;\n}\n\nexport namespace ActiveContextTimeToLive {\n  export const filterSensitiveLog = (obj: ActiveContextTimeToLive): any => ({\n    ...obj,\n  });\n}\n\n/**\n * <p>A context is a variable that contains information about the current state of the\n *       conversation between a user and Amazon Lex. Context can be set automatically by Amazon Lex when an\n *       intent is fulfilled, or it can be set at runtime using the <code>PutContent</code>,\n *         <code>PutText</code>, or <code>PutSession</code> operation.</p>\n */\nexport interface ActiveContext {\n  /**\n   * <p>The name of the context.</p>\n   */\n  name: string | undefined;\n\n  /**\n   * <p>The length of time or number of turns that a context remains active.</p>\n   */\n  timeToLive: ActiveContextTimeToLive | undefined;\n\n  /**\n   * <p>State variables for the current context. You can use these values as default values for\n   *       slots in subsequent events.</p>\n   */\n  parameters: { [key: string]: string } | undefined;\n}\n\nexport namespace ActiveContext {\n  export const filterSensitiveLog = (obj: ActiveContext): any => ({\n    ...obj,\n    ...(obj.parameters && { parameters: SENSITIVE_STRING }),\n  });\n}\n\n/**\n * <p> Request validation failed, there is no usable message in the context, or the bot build\n *       failed, is still in progress, or contains unbuilt changes. </p>\n */\nexport interface BadRequestException extends __SmithyException, $MetadataBearer {\n  name: \"BadRequestException\";\n  $fault: \"client\";\n  message?: string;\n}\n\nexport namespace BadRequestException {\n  export const filterSensitiveLog = (obj: BadRequestException): any => ({\n    ...obj,\n  });\n}\n\n/**\n * <p> Two clients are using the same AWS account, Amazon Lex bot, and user ID. </p>\n */\nexport interface ConflictException extends __SmithyException, $MetadataBearer {\n  name: \"ConflictException\";\n  $fault: \"client\";\n  message?: string;\n}\n\nexport namespace ConflictException {\n  export const filterSensitiveLog = (obj: ConflictException): any => ({\n    ...obj,\n  });\n}\n\nexport interface DeleteSessionRequest {\n  /**\n   * <p>The name of the bot that contains the session data.</p>\n   */\n  botName: string | undefined;\n\n  /**\n   * <p>The alias in use for the bot that contains the session data.</p>\n   */\n  botAlias: string | undefined;\n\n  /**\n   * <p>The identifier of the user associated with the session data.</p>\n   */\n  userId: string | undefined;\n}\n\nexport namespace DeleteSessionRequest {\n  export const filterSensitiveLog = (obj: DeleteSessionRequest): any => ({\n    ...obj,\n  });\n}\n\nexport interface DeleteSessionResponse {\n  /**\n   * <p>The name of the bot associated with the session data.</p>\n   */\n  botName?: string;\n\n  /**\n   * <p>The alias in use for the bot associated with the session data.</p>\n   */\n  botAlias?: string;\n\n  /**\n   * <p>The ID of the client application user.</p>\n   */\n  userId?: string;\n\n  /**\n   * <p>The unique identifier for the session.</p>\n   */\n  sessionId?: string;\n}\n\nexport namespace DeleteSessionResponse {\n  export const filterSensitiveLog = (obj: DeleteSessionResponse): any => ({\n    ...obj,\n  });\n}\n\n/**\n * <p>Internal service error. Retry the call.</p>\n */\nexport interface InternalFailureException extends __SmithyException, $MetadataBearer {\n  name: \"InternalFailureException\";\n  $fault: \"server\";\n  message?: string;\n}\n\nexport namespace InternalFailureException {\n  export const filterSensitiveLog = (obj: InternalFailureException): any => ({\n    ...obj,\n  });\n}\n\n/**\n * <p>Exceeded a limit.</p>\n */\nexport interface LimitExceededException extends __SmithyException, $MetadataBearer {\n  name: \"LimitExceededException\";\n  $fault: \"client\";\n  retryAfterSeconds?: string;\n  message?: string;\n}\n\nexport namespace LimitExceededException {\n  export const filterSensitiveLog = (obj: LimitExceededException): any => ({\n    ...obj,\n  });\n}\n\n/**\n * <p>The resource (such as the Amazon Lex bot or an alias) that is referred to is not\n *       found.</p>\n */\nexport interface NotFoundException extends __SmithyException, $MetadataBearer {\n  name: \"NotFoundException\";\n  $fault: \"client\";\n  message?: string;\n}\n\nexport namespace NotFoundException {\n  export const filterSensitiveLog = (obj: NotFoundException): any => ({\n    ...obj,\n  });\n}\n\nexport interface GetSessionRequest {\n  /**\n   * <p>The name of the bot that contains the session data.</p>\n   */\n  botName: string | undefined;\n\n  /**\n   * <p>The alias in use for the bot that contains the session data.</p>\n   */\n  botAlias: string | undefined;\n\n  /**\n   * <p>The ID of the client application user. Amazon Lex uses this to identify a user's conversation\n   *       with your bot. </p>\n   */\n  userId: string | undefined;\n\n  /**\n   * <p>A string used to filter the intents returned in the <code>recentIntentSummaryView</code>\n   *       structure. </p>\n   *          <p>When you specify a filter, only intents with their <code>checkpointLabel</code> field set\n   *       to that string are returned.</p>\n   */\n  checkpointLabelFilter?: string;\n}\n\nexport namespace GetSessionRequest {\n  export const filterSensitiveLog = (obj: GetSessionRequest): any => ({\n    ...obj,\n  });\n}\n\nexport enum FulfillmentState {\n  FAILED = \"Failed\",\n  FULFILLED = \"Fulfilled\",\n  READY_FOR_FULFILLMENT = \"ReadyForFulfillment\",\n}\n\nexport enum MessageFormatType {\n  COMPOSITE = \"Composite\",\n  CUSTOM_PAYLOAD = \"CustomPayload\",\n  PLAIN_TEXT = \"PlainText\",\n  SSML = \"SSML\",\n}\n\nexport enum DialogActionType {\n  CLOSE = \"Close\",\n  CONFIRM_INTENT = \"ConfirmIntent\",\n  DELEGATE = \"Delegate\",\n  ELICIT_INTENT = \"ElicitIntent\",\n  ELICIT_SLOT = \"ElicitSlot\",\n}\n\n/**\n * <p>Describes the next action that the bot should take in its interaction with the user and\n *       provides information about the context in which the action takes place. Use the\n *         <code>DialogAction</code> data type to set the interaction to a specific state, or to return\n *       the interaction to a previous state.</p>\n */\nexport interface DialogAction {\n  /**\n   * <p>The next action that the bot should take in its interaction with the user. The possible\n   *       values are:</p>\n   *          <ul>\n   *             <li>\n   *                <p>\n   *                   <code>ConfirmIntent</code> - The next action is asking the user if the intent is\n   *           complete and ready to be fulfilled. This is a yes/no question such as \"Place the\n   *           order?\"</p>\n   *             </li>\n   *             <li>\n   *                <p>\n   *                   <code>Close</code> - Indicates that the there will not be a response from the user.\n   *           For example, the statement \"Your order has been placed\" does not require a\n   *           response.</p>\n   *             </li>\n   *             <li>\n   *                <p>\n   *                   <code>Delegate</code> - The next action is determined by Amazon Lex.</p>\n   *             </li>\n   *             <li>\n   *                <p>\n   *                   <code>ElicitIntent</code> - The next action is to determine the intent that the user\n   *           wants to fulfill.</p>\n   *             </li>\n   *             <li>\n   *                <p>\n   *                   <code>ElicitSlot</code> - The next action is to elicit a slot value from the\n   *           user.</p>\n   *             </li>\n   *          </ul>\n   */\n  type: DialogActionType | string | undefined;\n\n  /**\n   * <p>The name of the intent.</p>\n   */\n  intentName?: string;\n\n  /**\n   * <p>Map of the slots that have been gathered and their values. </p>\n   */\n  slots?: { [key: string]: string };\n\n  /**\n   * <p>The name of the slot that should be elicited from the user.</p>\n   */\n  slotToElicit?: string;\n\n  /**\n   * <p>The fulfillment state of the intent. The possible values are:</p>\n   *          <ul>\n   *             <li>\n   *                <p>\n   *                   <code>Failed</code> - The Lambda function associated with the intent failed to fulfill\n   *           the intent.</p>\n   *             </li>\n   *             <li>\n   *                <p>\n   *                   <code>Fulfilled</code> - The intent has fulfilled by the Lambda function associated\n   *           with the intent. </p>\n   *             </li>\n   *             <li>\n   *                <p>\n   *                   <code>ReadyForFulfillment</code> - All of the information necessary for the intent is\n   *           present and the intent ready to be fulfilled by the client application.</p>\n   *             </li>\n   *          </ul>\n   */\n  fulfillmentState?: FulfillmentState | string;\n\n  /**\n   * <p>The message that should be shown to the user. If you don't specify a message, Amazon Lex will\n   *       use the message configured for the intent.</p>\n   */\n  message?: string;\n\n  /**\n   * <ul>\n   *             <li>\n   *                <p>\n   *                   <code>PlainText</code> - The message contains plain UTF-8 text.</p>\n   *             </li>\n   *             <li>\n   *                <p>\n   *                   <code>CustomPayload</code> - The message is a custom format for the client.</p>\n   *             </li>\n   *             <li>\n   *                <p>\n   *                   <code>SSML</code> - The message contains text formatted for voice output.</p>\n   *             </li>\n   *             <li>\n   *                <p>\n   *                   <code>Composite</code> - The message contains an escaped JSON object containing one or\n   *           more messages. For more information, see <a href=\"https://docs.aws.amazon.com/lex/latest/dg/howitworks-manage-prompts.html\">Message\n   *             Groups</a>. </p>\n   *             </li>\n   *          </ul>\n   */\n  messageFormat?: MessageFormatType | string;\n}\n\nexport namespace DialogAction {\n  export const filterSensitiveLog = (obj: DialogAction): any => ({\n    ...obj,\n    ...(obj.slots && { slots: SENSITIVE_STRING }),\n    ...(obj.message && { message: SENSITIVE_STRING }),\n  });\n}\n\nexport enum ConfirmationStatus {\n  CONFIRMED = \"Confirmed\",\n  DENIED = \"Denied\",\n  NONE = \"None\",\n}\n\n/**\n * <p>Provides information about the state of an intent. You can use this information to get the\n *       current state of an intent so that you can process the intent, or so that you can return the\n *       intent to its previous state.</p>\n */\nexport interface IntentSummary {\n  /**\n   * <p>The name of the intent.</p>\n   */\n  intentName?: string;\n\n  /**\n   * <p>A user-defined label that identifies a particular intent. You can use this label to return\n   *       to a previous intent. </p>\n   *          <p>Use the <code>checkpointLabelFilter</code> parameter of the <code>GetSessionRequest</code>\n   *       operation to filter the intents returned by the operation to those with only the specified\n   *       label.</p>\n   */\n  checkpointLabel?: string;\n\n  /**\n   * <p>Map of the slots that have been gathered and their values. </p>\n   */\n  slots?: { [key: string]: string };\n\n  /**\n   * <p>The status of the intent after the user responds to the confirmation prompt. If the user\n   *       confirms the intent, Amazon Lex sets this field to <code>Confirmed</code>. If the user denies the\n   *       intent, Amazon Lex sets this value to <code>Denied</code>. The possible values are:</p>\n   *          <ul>\n   *             <li>\n   *                <p>\n   *                   <code>Confirmed</code> - The user has responded \"Yes\" to the confirmation prompt,\n   *           confirming that the intent is complete and that it is ready to be fulfilled.</p>\n   *             </li>\n   *             <li>\n   *                <p>\n   *                   <code>Denied</code> - The user has responded \"No\" to the confirmation prompt.</p>\n   *             </li>\n   *             <li>\n   *                <p>\n   *                   <code>None</code> - The user has never been prompted for confirmation; or, the user\n   *           was prompted but did not confirm or deny the prompt.</p>\n   *             </li>\n   *          </ul>\n   */\n  confirmationStatus?: ConfirmationStatus | string;\n\n  /**\n   * <p>The next action that the bot should take in its interaction with the user. The possible\n   *       values are:</p>\n   *          <ul>\n   *             <li>\n   *                <p>\n   *                   <code>ConfirmIntent</code> - The next action is asking the user if the intent is\n   *           complete and ready to be fulfilled. This is a yes/no question such as \"Place the\n   *           order?\"</p>\n   *             </li>\n   *             <li>\n   *                <p>\n   *                   <code>Close</code> - Indicates that the there will not be a response from the user.\n   *           For example, the statement \"Your order has been placed\" does not require a\n   *           response.</p>\n   *             </li>\n   *             <li>\n   *                <p>\n   *                   <code>ElicitIntent</code> - The next action is to determine the intent that the user\n   *           wants to fulfill.</p>\n   *             </li>\n   *             <li>\n   *                <p>\n   *                   <code>ElicitSlot</code> - The next action is to elicit a slot value from the\n   *           user.</p>\n   *             </li>\n   *          </ul>\n   */\n  dialogActionType: DialogActionType | string | undefined;\n\n  /**\n   * <p>The fulfillment state of the intent. The possible values are:</p>\n   *          <ul>\n   *             <li>\n   *                <p>\n   *                   <code>Failed</code> - The Lambda function associated with the intent failed to fulfill\n   *           the intent.</p>\n   *             </li>\n   *             <li>\n   *                <p>\n   *                   <code>Fulfilled</code> - The intent has fulfilled by the Lambda function associated\n   *           with the intent. </p>\n   *             </li>\n   *             <li>\n   *                <p>\n   *                   <code>ReadyForFulfillment</code> - All of the information necessary for the intent is\n   *           present and the intent ready to be fulfilled by the client application.</p>\n   *             </li>\n   *          </ul>\n   */\n  fulfillmentState?: FulfillmentState | string;\n\n  /**\n   * <p>The next slot to elicit from the user. If there is not slot to elicit, the field is\n   *       blank.</p>\n   */\n  slotToElicit?: string;\n}\n\nexport namespace IntentSummary {\n  export const filterSensitiveLog = (obj: IntentSummary): any => ({\n    ...obj,\n    ...(obj.slots && { slots: SENSITIVE_STRING }),\n  });\n}\n\nexport interface GetSessionResponse {\n  /**\n   * <p>An array of information about the intents used in the session. The array can contain a\n   *       maximum of three summaries. If more than three intents are used in the session, the\n   *         <code>recentIntentSummaryView</code> operation contains information about the last three\n   *       intents used.</p>\n   *          <p>If you set the <code>checkpointLabelFilter</code> parameter in the request, the array\n   *       contains only the intents with the specified label.</p>\n   */\n  recentIntentSummaryView?: IntentSummary[];\n\n  /**\n   * <p>Map of key/value pairs representing the session-specific context information. It contains\n   *       application information passed between Amazon Lex and a client application.</p>\n   */\n  sessionAttributes?: { [key: string]: string };\n\n  /**\n   * <p>A unique identifier for the session.</p>\n   */\n  sessionId?: string;\n\n  /**\n   * <p>Describes the current state of the bot.</p>\n   */\n  dialogAction?: DialogAction;\n\n  /**\n   * <p>A list of active contexts for the session. A context can be set when an intent\n   *     is fulfilled or by calling the <code>PostContent</code>, <code>PostText</code>,\n   *     or <code>PutSession</code> operation.</p>\n   *          <p>You can use a context to control the intents that can follow up an intent,\n   *     or to modify the operation of your application.</p>\n   */\n  activeContexts?: ActiveContext[];\n}\n\nexport namespace GetSessionResponse {\n  export const filterSensitiveLog = (obj: GetSessionResponse): any => ({\n    ...obj,\n    ...(obj.recentIntentSummaryView && {\n      recentIntentSummaryView: obj.recentIntentSummaryView.map((item) => IntentSummary.filterSensitiveLog(item)),\n    }),\n    ...(obj.sessionAttributes && { sessionAttributes: SENSITIVE_STRING }),\n    ...(obj.dialogAction && { dialogAction: DialogAction.filterSensitiveLog(obj.dialogAction) }),\n    ...(obj.activeContexts && { activeContexts: SENSITIVE_STRING }),\n  });\n}\n\n/**\n * <p>Either the Amazon Lex bot is still building, or one of the dependent services (Amazon Polly,\n *       AWS Lambda) failed with an internal service error.</p>\n */\nexport interface BadGatewayException extends __SmithyException, $MetadataBearer {\n  name: \"BadGatewayException\";\n  $fault: \"server\";\n  Message?: string;\n}\n\nexport namespace BadGatewayException {\n  export const filterSensitiveLog = (obj: BadGatewayException): any => ({\n    ...obj,\n  });\n}\n\n/**\n * <p> One of the dependencies, such as AWS Lambda or Amazon Polly, threw an exception. For example, </p>\n *          <ul>\n *             <li>\n *                <p>If Amazon Lex does not have sufficient permissions to call a Lambda function.</p>\n *             </li>\n *             <li>\n *                <p>If a Lambda function takes longer than 30 seconds to execute.</p>\n *             </li>\n *             <li>\n *                <p>If a fulfillment Lambda function returns a <code>Delegate</code> dialog action without\n *           removing any slot values.</p>\n *             </li>\n *          </ul>\n */\nexport interface DependencyFailedException extends __SmithyException, $MetadataBearer {\n  name: \"DependencyFailedException\";\n  $fault: \"client\";\n  Message?: string;\n}\n\nexport namespace DependencyFailedException {\n  export const filterSensitiveLog = (obj: DependencyFailedException): any => ({\n    ...obj,\n  });\n}\n\n/**\n * <p>This exception is not used.</p>\n */\nexport interface LoopDetectedException extends __SmithyException, $MetadataBearer {\n  name: \"LoopDetectedException\";\n  $fault: \"server\";\n  Message?: string;\n}\n\nexport namespace LoopDetectedException {\n  export const filterSensitiveLog = (obj: LoopDetectedException): any => ({\n    ...obj,\n  });\n}\n\n/**\n * <p>The accept header in the request does not have a valid value.</p>\n */\nexport interface NotAcceptableException extends __SmithyException, $MetadataBearer {\n  name: \"NotAcceptableException\";\n  $fault: \"client\";\n  message?: string;\n}\n\nexport namespace NotAcceptableException {\n  export const filterSensitiveLog = (obj: NotAcceptableException): any => ({\n    ...obj,\n  });\n}\n\nexport interface PostContentRequest {\n  /**\n   * <p>Name of the Amazon Lex bot.</p>\n   */\n  botName: string | undefined;\n\n  /**\n   * <p>Alias of the Amazon Lex bot.</p>\n   */\n  botAlias: string | undefined;\n\n  /**\n   * <p>The ID of the client application user. Amazon Lex uses this to identify a user's conversation\n   *       with your bot. At runtime, each request must contain the <code>userID</code> field.</p>\n   *          <p>To decide the user ID to use for your application, consider the following factors.</p>\n   *          <ul>\n   *             <li>\n   *                <p>The <code>userID</code> field must not contain any personally identifiable information\n   *           of the user, for example, name, personal identification numbers, or other end user\n   *           personal information.</p>\n   *             </li>\n   *             <li>\n   *                <p>If you want a user to start a conversation on one device and continue on another\n   *           device, use a user-specific identifier.</p>\n   *             </li>\n   *             <li>\n   *                <p>If you want the same user to be able to have two independent conversations on two\n   *           different devices, choose a device-specific identifier.</p>\n   *             </li>\n   *             <li>\n   *                <p>A user can't have two independent conversations with two different versions of the\n   *           same bot. For example, a user can't have a conversation with the PROD and BETA versions of\n   *           the same bot. If you anticipate that a user will need to have conversation with two\n   *           different versions, for example, while testing, include the bot alias in the user ID to\n   *           separate the two conversations.</p>\n   *             </li>\n   *          </ul>\n   */\n  userId: string | undefined;\n\n  /**\n   * <p>You pass this value as the <code>x-amz-lex-session-attributes</code> HTTP header.</p>\n   *          <p>Application-specific information passed between Amazon Lex and a client application. The value\n   *       must be a JSON serialized and base64 encoded map with string keys and values. The total size\n   *       of the <code>sessionAttributes</code> and <code>requestAttributes</code> headers is limited to\n   *       12 KB.</p>\n   *          <p>For more information, see <a href=\"https://docs.aws.amazon.com/lex/latest/dg/context-mgmt.html#context-mgmt-session-attribs\">Setting Session\n   *         Attributes</a>.</p>\n   */\n  sessionAttributes?: __LazyJsonString | string;\n\n  /**\n   * <p>You pass this value as the <code>x-amz-lex-request-attributes</code> HTTP header.</p>\n   *          <p>Request-specific information passed between Amazon Lex and a client application. The value must\n   *       be a JSON serialized and base64 encoded map with string keys and values. The total size of the\n   *         <code>requestAttributes</code> and <code>sessionAttributes</code> headers is limited to 12\n   *       KB.</p>\n   *          <p>The namespace <code>x-amz-lex:</code> is reserved for special attributes. Don't create any\n   *       request attributes with the prefix <code>x-amz-lex:</code>.</p>\n   *          <p>For more information, see <a href=\"https://docs.aws.amazon.com/lex/latest/dg/context-mgmt.html#context-mgmt-request-attribs\">Setting Request\n   *         Attributes</a>.</p>\n   */\n  requestAttributes?: __LazyJsonString | string;\n\n  /**\n   * <p> You pass this value as the <code>Content-Type</code> HTTP header. </p>\n   *          <p> Indicates the audio format or text. The header value must start with one of the following\n   *       prefixes: </p>\n   *          <ul>\n   *             <li>\n   *                <p>PCM format, audio data must be in little-endian byte order.</p>\n   *                <ul>\n   *                   <li>\n   *                      <p>audio/l16; rate=16000; channels=1</p>\n   *                   </li>\n   *                   <li>\n   *                      <p>audio/x-l16; sample-rate=16000; channel-count=1</p>\n   *                   </li>\n   *                   <li>\n   *                      <p>audio/lpcm; sample-rate=8000; sample-size-bits=16; channel-count=1;\n   *               is-big-endian=false </p>\n   *                   </li>\n   *                </ul>\n   *             </li>\n   *             <li>\n   *                <p>Opus format</p>\n   *                <ul>\n   *                   <li>\n   *                      <p>audio/x-cbr-opus-with-preamble; preamble-size=0; bit-rate=256000;\n   *               frame-size-milliseconds=4</p>\n   *                   </li>\n   *                </ul>\n   *             </li>\n   *             <li>\n   *                <p>Text format</p>\n   *                <ul>\n   *                   <li>\n   *                      <p>text/plain; charset=utf-8</p>\n   *                   </li>\n   *                </ul>\n   *             </li>\n   *          </ul>\n   */\n  contentType: string | undefined;\n\n  /**\n   * <p> You pass this value as the <code>Accept</code> HTTP header. </p>\n   *          <p> The message Amazon Lex returns in the response can be either text or speech based on the\n   *         <code>Accept</code> HTTP header value in the request. </p>\n   *          <ul>\n   *             <li>\n   *                <p> If the value is <code>text/plain; charset=utf-8</code>, Amazon Lex returns text in the\n   *           response. </p>\n   *             </li>\n   *             <li>\n   *                <p> If the value begins with <code>audio/</code>, Amazon Lex returns speech in the response.\n   *           Amazon Lex uses Amazon Polly to generate the speech (using the configuration you specified in the\n   *             <code>Accept</code> header). For example, if you specify <code>audio/mpeg</code> as the\n   *           value, Amazon Lex returns speech in the MPEG format.</p>\n   *             </li>\n   *             <li>\n   *                <p>If the value is <code>audio/pcm</code>, the speech returned is <code>audio/pcm</code>\n   *           in 16-bit, little endian format.\n   *           </p>\n   *             </li>\n   *             <li>\n   *                <p>The following are the accepted values:</p>\n   *                <ul>\n   *                   <li>\n   *                      <p>audio/mpeg</p>\n   *                   </li>\n   *                   <li>\n   *                      <p>audio/ogg</p>\n   *                   </li>\n   *                   <li>\n   *                      <p>audio/pcm</p>\n   *                   </li>\n   *                   <li>\n   *                      <p>text/plain; charset=utf-8</p>\n   *                   </li>\n   *                   <li>\n   *                      <p>audio/* (defaults to mpeg)</p>\n   *                   </li>\n   *                </ul>\n   *             </li>\n   *          </ul>\n   */\n  accept?: string;\n\n  /**\n   * <p> User input in PCM or Opus audio format or text format as described in the\n   *         <code>Content-Type</code> HTTP header. </p>\n   *          <p>You can stream audio data to Amazon Lex or you can create a local buffer that captures all of\n   *       the audio data before sending. In general, you get better performance if you stream audio data\n   *       rather than buffering the data locally.</p>\n   */\n  inputStream: Readable | ReadableStream | Blob | undefined;\n\n  /**\n   * <p>A list of contexts active for the request. A context can be activated when a previous\n   *       intent is fulfilled, or by including the context in the request,</p>\n   *          <p>If you don't specify a list of contexts, Amazon Lex will use the current list of contexts for\n   *       the session. If you specify an empty list, all contexts for the session are cleared.</p>\n   */\n  activeContexts?: __LazyJsonString | string;\n}\n\nexport namespace PostContentRequest {\n  export const filterSensitiveLog = (obj: PostContentRequest): any => ({\n    ...obj,\n    ...(obj.sessionAttributes && { sessionAttributes: SENSITIVE_STRING }),\n    ...(obj.requestAttributes && { requestAttributes: SENSITIVE_STRING }),\n    ...(obj.activeContexts && { activeContexts: SENSITIVE_STRING }),\n  });\n}\n\nexport enum DialogState {\n  CONFIRM_INTENT = \"ConfirmIntent\",\n  ELICIT_INTENT = \"ElicitIntent\",\n  ELICIT_SLOT = \"ElicitSlot\",\n  FAILED = \"Failed\",\n  FULFILLED = \"Fulfilled\",\n  READY_FOR_FULFILLMENT = \"ReadyForFulfillment\",\n}\n\nexport interface PostContentResponse {\n  /**\n   * <p>Content type as specified in the <code>Accept</code> HTTP header in the request.</p>\n   */\n  contentType?: string;\n\n  /**\n   * <p>Current user intent that Amazon Lex is aware of.</p>\n   */\n  intentName?: string;\n\n  /**\n   * <p>Provides a score that indicates how confident Amazon Lex is that the returned intent is the one\n   *       that matches the user's intent. The score is between 0.0 and 1.0.</p>\n   *          <p>The score is a relative score, not an absolute score. The score may change based on\n   *       improvements to Amazon Lex. </p>\n   */\n  nluIntentConfidence?: __LazyJsonString | string;\n\n  /**\n   * <p>One to four alternative intents that may be applicable to the user's intent.</p>\n   *          <p>Each alternative includes a score that indicates how confident Amazon Lex is that the intent\n   *       matches the user's intent. The intents are sorted by the confidence score.</p>\n   */\n  alternativeIntents?: __LazyJsonString | string;\n\n  /**\n   * <p>Map of zero or more intent slots (name/value pairs) Amazon Lex detected from the user input\n   *       during the conversation. The field is base-64 encoded.</p>\n   *          <p>Amazon Lex creates a resolution list containing likely values for a slot. The value that it\n   *       returns is determined by the <code>valueSelectionStrategy</code> selected when the slot type\n   *       was created or updated. If <code>valueSelectionStrategy</code> is set to\n   *         <code>ORIGINAL_VALUE</code>, the value provided by the user is returned, if the user value\n   *       is similar to the slot values. If <code>valueSelectionStrategy</code> is set to\n   *         <code>TOP_RESOLUTION</code> Amazon Lex returns the first value in the resolution list or, if\n   *       there is no resolution list, null. If you don't specify a <code>valueSelectionStrategy</code>,\n   *       the default is <code>ORIGINAL_VALUE</code>.</p>\n   */\n  slots?: __LazyJsonString | string;\n\n  /**\n   * <p> Map of key/value pairs representing the session-specific context information. </p>\n   */\n  sessionAttributes?: __LazyJsonString | string;\n\n  /**\n   * <p>The sentiment expressed in an utterance.</p>\n   *          <p>When the bot is configured to send utterances to Amazon Comprehend for sentiment analysis,\n   *       this field contains the result of the analysis.</p>\n   */\n  sentimentResponse?: string;\n\n  /**\n   * <p>The message to convey to the user. The message can come from the bot's configuration or\n   *       from a Lambda function.</p>\n   *          <p>If the intent is not configured with a Lambda function, or if the Lambda function returned\n   *         <code>Delegate</code> as the <code>dialogAction.type</code> in its response, Amazon Lex decides\n   *       on the next course of action and selects an appropriate message from the bot's configuration\n   *       based on the current interaction context. For example, if Amazon Lex isn't able to understand user\n   *       input, it uses a clarification prompt message.</p>\n   *          <p>When you create an intent you can assign messages to groups. When messages are assigned to\n   *       groups Amazon Lex returns one message from each group in the response. The message field is an\n   *       escaped JSON string containing the messages. For more information about the structure of the\n   *       JSON string returned, see <a>msg-prompts-formats</a>.</p>\n   *          <p>If the Lambda function returns a message, Amazon Lex passes it to the client in its\n   *       response.</p>\n   */\n  message?: string;\n\n  /**\n   * <p>The format of the response message. One of the following values:</p>\n   *          <ul>\n   *             <li>\n   *                <p>\n   *                   <code>PlainText</code> - The message contains plain UTF-8 text.</p>\n   *             </li>\n   *             <li>\n   *                <p>\n   *                   <code>CustomPayload</code> - The message is a custom format for the client.</p>\n   *             </li>\n   *             <li>\n   *                <p>\n   *                   <code>SSML</code> - The message contains text formatted for voice output.</p>\n   *             </li>\n   *             <li>\n   *                <p>\n   *                   <code>Composite</code> - The message contains an escaped JSON object containing one or\n   *           more messages from the groups that messages were assigned to when the intent was\n   *           created.</p>\n   *             </li>\n   *          </ul>\n   */\n  messageFormat?: MessageFormatType | string;\n\n  /**\n   * <p>Identifies the current state of the user interaction. Amazon Lex returns one of the following\n   *       values as <code>dialogState</code>. The client can optionally use this information to\n   *       customize the user interface. </p>\n   *          <ul>\n   *             <li>\n   *                <p>\n   *                   <code>ElicitIntent</code> - Amazon Lex wants to elicit the user's intent. Consider the\n   *           following examples: </p>\n   *                <p> For example, a user might utter an intent (\"I want to order a pizza\"). If Amazon Lex\n   *           cannot infer the user intent from this utterance, it will return this dialog state.\n   *         </p>\n   *             </li>\n   *             <li>\n   *                <p>\n   *                   <code>ConfirmIntent</code> - Amazon Lex is expecting a \"yes\" or \"no\" response. </p>\n   *                <p>For example, Amazon Lex wants user confirmation before fulfilling an intent. Instead of a\n   *           simple \"yes\" or \"no\" response, a user might respond with additional information. For\n   *           example, \"yes, but make it a thick crust pizza\" or \"no, I want to order a drink.\" Amazon Lex\n   *           can process such additional information (in these examples, update the crust type slot or\n   *           change the intent from OrderPizza to OrderDrink). </p>\n   *             </li>\n   *             <li>\n   *                <p>\n   *                   <code>ElicitSlot</code> - Amazon Lex is expecting the value of a slot for the current intent. </p>\n   *                <p> For example, suppose that in the response Amazon Lex sends this message: \"What size pizza\n   *           would you like?\". A user might reply with the slot value (e.g., \"medium\"). The user might\n   *           also provide additional information in the response (e.g., \"medium thick crust pizza\").\n   *           Amazon Lex can process such additional information appropriately. </p>\n   *             </li>\n   *             <li>\n   *                <p>\n   *                   <code>Fulfilled</code> - Conveys that the Lambda function has successfully fulfilled the\n   *           intent. </p>\n   *             </li>\n   *             <li>\n   *                <p>\n   *                   <code>ReadyForFulfillment</code> - Conveys that the client has to fulfill the request.\n   *         </p>\n   *             </li>\n   *             <li>\n   *                <p>\n   *                   <code>Failed</code> - Conveys that the conversation with the user failed. </p>\n   *                <p> This can happen for various reasons, including that the user does not provide an\n   *           appropriate response to prompts from the service (you can configure how many times Amazon Lex\n   *           can prompt a user for specific information), or if the Lambda function fails to fulfill the\n   *           intent. </p>\n   *             </li>\n   *          </ul>\n   */\n  dialogState?: DialogState | string;\n\n  /**\n   * <p> If the <code>dialogState</code> value is <code>ElicitSlot</code>, returns the name of the\n   *       slot for which Amazon Lex is eliciting a value. </p>\n   */\n  slotToElicit?: string;\n\n  /**\n   * <p>The text used to process the request.</p>\n   *          <p>If the input was an audio stream, the <code>inputTranscript</code> field contains the text\n   *       extracted from the audio stream. This is the text that is actually processed to recognize\n   *       intents and slot values. You can use this information to determine if Amazon Lex is correctly\n   *       processing the audio that you send.</p>\n   */\n  inputTranscript?: string;\n\n  /**\n   * <p>The prompt (or statement) to convey to the user. This is based on the bot configuration\n   *       and context. For example, if Amazon Lex did not understand the user intent, it sends the\n   *         <code>clarificationPrompt</code> configured for the bot. If the intent requires confirmation\n   *       before taking the fulfillment action, it sends the <code>confirmationPrompt</code>. Another\n   *       example: Suppose that the Lambda function successfully fulfilled the intent, and sent a message\n   *       to convey to the user. Then Amazon Lex sends that message in the response. </p>\n   */\n  audioStream?: Readable | ReadableStream | Blob;\n\n  /**\n   * <p>The version of the bot that responded to the conversation. You can use this information to\n   *       help determine if one version of a bot is performing better than another version.</p>\n   */\n  botVersion?: string;\n\n  /**\n   * <p>The unique identifier for the session.</p>\n   */\n  sessionId?: string;\n\n  /**\n   * <p>A list of active contexts for the session. A context can be set when an intent\n   *       is fulfilled or by calling the <code>PostContent</code>, <code>PostText</code>,\n   *       or <code>PutSession</code> operation.</p>\n   *          <p>You can use a context to control the intents that can follow up an intent,\n   *       or to modify the operation of your application.</p>\n   */\n  activeContexts?: __LazyJsonString | string;\n}\n\nexport namespace PostContentResponse {\n  export const filterSensitiveLog = (obj: PostContentResponse): any => ({\n    ...obj,\n    ...(obj.message && { message: SENSITIVE_STRING }),\n    ...(obj.activeContexts && { activeContexts: SENSITIVE_STRING }),\n  });\n}\n\n/**\n * <p>The input speech is too long.</p>\n */\nexport interface RequestTimeoutException extends __SmithyException, $MetadataBearer {\n  name: \"RequestTimeoutException\";\n  $fault: \"client\";\n  message?: string;\n}\n\nexport namespace RequestTimeoutException {\n  export const filterSensitiveLog = (obj: RequestTimeoutException): any => ({\n    ...obj,\n  });\n}\n\n/**\n * <p>The Content-Type header (<code>PostContent</code> API) has an invalid value. </p>\n */\nexport interface UnsupportedMediaTypeException extends __SmithyException, $MetadataBearer {\n  name: \"UnsupportedMediaTypeException\";\n  $fault: \"client\";\n  message?: string;\n}\n\nexport namespace UnsupportedMediaTypeException {\n  export const filterSensitiveLog = (obj: UnsupportedMediaTypeException): any => ({\n    ...obj,\n  });\n}\n\nexport interface PostTextRequest {\n  /**\n   * <p>The name of the Amazon Lex bot.</p>\n   */\n  botName: string | undefined;\n\n  /**\n   * <p>The alias of the Amazon Lex bot.</p>\n   */\n  botAlias: string | undefined;\n\n  /**\n   * <p>The ID of the client application user. Amazon Lex uses this to identify a user's conversation\n   *       with your bot. At runtime, each request must contain the <code>userID</code> field.</p>\n   *          <p>To decide the user ID to use for your application, consider the following factors.</p>\n   *          <ul>\n   *             <li>\n   *                <p>The <code>userID</code> field must not contain any personally identifiable information\n   *           of the user, for example, name, personal identification numbers, or other end user\n   *           personal information.</p>\n   *             </li>\n   *             <li>\n   *                <p>If you want a user to start a conversation on one device and continue on another\n   *           device, use a user-specific identifier.</p>\n   *             </li>\n   *             <li>\n   *                <p>If you want the same user to be able to have two independent conversations on two\n   *           different devices, choose a device-specific identifier.</p>\n   *             </li>\n   *             <li>\n   *                <p>A user can't have two independent conversations with two different versions of the\n   *           same bot. For example, a user can't have a conversation with the PROD and BETA versions of\n   *           the same bot. If you anticipate that a user will need to have conversation with two\n   *           different versions, for example, while testing, include the bot alias in the user ID to\n   *           separate the two conversations.</p>\n   *             </li>\n   *          </ul>\n   */\n  userId: string | undefined;\n\n  /**\n   * <p>Application-specific information passed between Amazon Lex and a client application.</p>\n   *          <p>For more information, see <a href=\"https://docs.aws.amazon.com/lex/latest/dg/context-mgmt.html#context-mgmt-session-attribs\">Setting Session\n   *         Attributes</a>.</p>\n   */\n  sessionAttributes?: { [key: string]: string };\n\n  /**\n   * <p>Request-specific information passed between Amazon Lex and a client application.</p>\n   *          <p>The namespace <code>x-amz-lex:</code> is reserved for special attributes. Don't create any\n   *       request attributes with the prefix <code>x-amz-lex:</code>.</p>\n   *          <p>For more information, see <a href=\"https://docs.aws.amazon.com/lex/latest/dg/context-mgmt.html#context-mgmt-request-attribs\">Setting Request\n   *         Attributes</a>.</p>\n   */\n  requestAttributes?: { [key: string]: string };\n\n  /**\n   * <p>The text that the user entered (Amazon Lex interprets this text).</p>\n   */\n  inputText: string | undefined;\n\n  /**\n   * <p>A list of contexts active for the request. A context can be activated when a previous\n   *       intent is fulfilled, or by including the context in the request,</p>\n   *          <p>If you don't specify a list of contexts, Amazon Lex will use the current list of contexts for\n   *       the session. If you specify an empty list, all contexts for the session are cleared.</p>\n   */\n  activeContexts?: ActiveContext[];\n}\n\nexport namespace PostTextRequest {\n  export const filterSensitiveLog = (obj: PostTextRequest): any => ({\n    ...obj,\n    ...(obj.sessionAttributes && { sessionAttributes: SENSITIVE_STRING }),\n    ...(obj.requestAttributes && { requestAttributes: SENSITIVE_STRING }),\n    ...(obj.inputText && { inputText: SENSITIVE_STRING }),\n    ...(obj.activeContexts && { activeContexts: SENSITIVE_STRING }),\n  });\n}\n\n/**\n * <p>Provides a score that indicates the confidence that Amazon Lex has that an intent is the one\n *       that satisfies the user's intent.</p>\n */\nexport interface IntentConfidence {\n  /**\n   * <p>A score that indicates how confident Amazon Lex is that an intent satisfies the user's intent.\n   *       Ranges between 0.00 and 1.00. Higher scores indicate higher confidence.</p>\n   */\n  score?: number;\n}\n\nexport namespace IntentConfidence {\n  export const filterSensitiveLog = (obj: IntentConfidence): any => ({\n    ...obj,\n  });\n}\n\n/**\n * <p>An intent that Amazon Lex suggests satisfies the user's intent. Includes the name of the\n *       intent, the confidence that Amazon Lex has that the user's intent is satisfied, and the slots\n *       defined for the intent.</p>\n */\nexport interface PredictedIntent {\n  /**\n   * <p>The name of the intent that Amazon Lex suggests satisfies the user's intent.</p>\n   */\n  intentName?: string;\n\n  /**\n   * <p>Indicates how confident Amazon Lex is that an intent satisfies the user's intent.</p>\n   */\n  nluIntentConfidence?: IntentConfidence;\n\n  /**\n   * <p>The slot and slot values associated with the predicted intent.</p>\n   */\n  slots?: { [key: string]: string };\n}\n\nexport namespace PredictedIntent {\n  export const filterSensitiveLog = (obj: PredictedIntent): any => ({\n    ...obj,\n    ...(obj.slots && { slots: SENSITIVE_STRING }),\n  });\n}\n\nexport enum ContentType {\n  GENERIC = \"application/vnd.amazonaws.card.generic\",\n}\n\n/**\n * <p>Represents an option to be shown on the client platform (Facebook, Slack, etc.)</p>\n */\nexport interface Button {\n  /**\n   * <p>Text that is visible to the user on the button.</p>\n   */\n  text: string | undefined;\n\n  /**\n   * <p>The value sent to Amazon Lex when a user chooses the button. For example, consider button\n   *       text \"NYC.\" When the user chooses the button, the value sent can be \"New York City.\"</p>\n   */\n  value: string | undefined;\n}\n\nexport namespace Button {\n  export const filterSensitiveLog = (obj: Button): any => ({\n    ...obj,\n  });\n}\n\n/**\n * <p>Represents an option rendered to the user when a prompt is shown. It could be an image, a\n *       button, a link, or text. </p>\n */\nexport interface GenericAttachment {\n  /**\n   * <p>The title of the option.</p>\n   */\n  title?: string;\n\n  /**\n   * <p>The subtitle shown below the title.</p>\n   */\n  subTitle?: string;\n\n  /**\n   * <p>The URL of an attachment to the response card.</p>\n   */\n  attachmentLinkUrl?: string;\n\n  /**\n   * <p>The URL of an image that is displayed to the user.</p>\n   */\n  imageUrl?: string;\n\n  /**\n   * <p>The list of options to show to the user.</p>\n   */\n  buttons?: Button[];\n}\n\nexport namespace GenericAttachment {\n  export const filterSensitiveLog = (obj: GenericAttachment): any => ({\n    ...obj,\n  });\n}\n\n/**\n * <p>If you configure a response card when creating your bots, Amazon Lex substitutes the session\n *       attributes and slot values that are available, and then returns it. The response card can also\n *       come from a Lambda function ( <code>dialogCodeHook</code> and <code>fulfillmentActivity</code>\n *       on an intent).</p>\n */\nexport interface ResponseCard {\n  /**\n   * <p>The version of the response card format.</p>\n   */\n  version?: string;\n\n  /**\n   * <p>The content type of the response.</p>\n   */\n  contentType?: ContentType | string;\n\n  /**\n   * <p>An array of attachment objects representing options.</p>\n   */\n  genericAttachments?: GenericAttachment[];\n}\n\nexport namespace ResponseCard {\n  export const filterSensitiveLog = (obj: ResponseCard): any => ({\n    ...obj,\n  });\n}\n\n/**\n * <p>The sentiment expressed in an utterance.</p>\n *          <p>When the bot is configured to send utterances to Amazon Comprehend for sentiment analysis,\n *       this field structure contains the result of the analysis.</p>\n */\nexport interface SentimentResponse {\n  /**\n   * <p>The inferred sentiment that Amazon Comprehend has the highest confidence in.</p>\n   */\n  sentimentLabel?: string;\n\n  /**\n   * <p>The likelihood that the sentiment was correctly inferred.</p>\n   */\n  sentimentScore?: string;\n}\n\nexport namespace SentimentResponse {\n  export const filterSensitiveLog = (obj: SentimentResponse): any => ({\n    ...obj,\n  });\n}\n\nexport interface PostTextResponse {\n  /**\n   * <p>The current user intent that Amazon Lex is aware of.</p>\n   */\n  intentName?: string;\n\n  /**\n   * <p>Provides a score that indicates how confident Amazon Lex is that the returned intent is the one\n   *       that matches the user's intent. The score is between 0.0 and 1.0. For more information, see\n   *         <a href=\"https://docs.aws.amazon.com/lex/latest/dg/confidence-scores.html\">Confidence\n   *         Scores</a>.</p>\n   *          <p>The score is a relative score, not an absolute score. The score may change based on\n   *       improvements to Amazon Lex.</p>\n   */\n  nluIntentConfidence?: IntentConfidence;\n\n  /**\n   * <p>One to four alternative intents that may be applicable to the user's intent.</p>\n   *          <p>Each alternative includes a score that indicates how confident Amazon Lex is that the intent\n   *       matches the user's intent. The intents are sorted by the confidence score.</p>\n   */\n  alternativeIntents?: PredictedIntent[];\n\n  /**\n   * <p> The intent slots that Amazon Lex detected from the user input in the conversation. </p>\n   *          <p>Amazon Lex creates a resolution list containing likely values for a slot. The value that it\n   *       returns is determined by the <code>valueSelectionStrategy</code> selected when the slot type\n   *       was created or updated. If <code>valueSelectionStrategy</code> is set to\n   *         <code>ORIGINAL_VALUE</code>, the value provided by the user is returned, if the user value\n   *       is similar to the slot values. If <code>valueSelectionStrategy</code> is set to\n   *         <code>TOP_RESOLUTION</code> Amazon Lex returns the first value in the resolution list or, if\n   *       there is no resolution list, null. If you don't specify a <code>valueSelectionStrategy</code>,\n   *       the default is <code>ORIGINAL_VALUE</code>.</p>\n   */\n  slots?: { [key: string]: string };\n\n  /**\n   * <p>A map of key-value pairs representing the session-specific context information.</p>\n   */\n  sessionAttributes?: { [key: string]: string };\n\n  /**\n   * <p>The message to convey to the user. The message can come from the bot's configuration or\n   *       from a Lambda function.</p>\n   *          <p>If the intent is not configured with a Lambda function, or if the Lambda function returned\n   *         <code>Delegate</code> as the <code>dialogAction.type</code> its response, Amazon Lex decides on\n   *       the next course of action and selects an appropriate message from the bot's configuration\n   *       based on the current interaction context. For example, if Amazon Lex isn't able to understand user\n   *       input, it uses a clarification prompt message.</p>\n   *          <p>When you create an intent you can assign messages to groups. When messages are assigned to\n   *       groups Amazon Lex returns one message from each group in the response. The message field is an\n   *       escaped JSON string containing the messages. For more information about the structure of the\n   *       JSON string returned, see <a>msg-prompts-formats</a>.</p>\n   *          <p>If the Lambda function returns a message, Amazon Lex passes it to the client in its\n   *       response.</p>\n   */\n  message?: string;\n\n  /**\n   * <p>The sentiment expressed in and utterance.</p>\n   *          <p>When the bot is configured to send utterances to Amazon Comprehend for sentiment analysis,\n   *       this field contains the result of the analysis.</p>\n   */\n  sentimentResponse?: SentimentResponse;\n\n  /**\n   * <p>The format of the response message. One of the following values:</p>\n   *          <ul>\n   *             <li>\n   *                <p>\n   *                   <code>PlainText</code> - The message contains plain UTF-8 text.</p>\n   *             </li>\n   *             <li>\n   *                <p>\n   *                   <code>CustomPayload</code> - The message is a custom format defined by the Lambda\n   *           function.</p>\n   *             </li>\n   *             <li>\n   *                <p>\n   *                   <code>SSML</code> - The message contains text formatted for voice output.</p>\n   *             </li>\n   *             <li>\n   *                <p>\n   *                   <code>Composite</code> - The message contains an escaped JSON object containing one or\n   *           more messages from the groups that messages were assigned to when the intent was\n   *           created.</p>\n   *             </li>\n   *          </ul>\n   */\n  messageFormat?: MessageFormatType | string;\n\n  /**\n   * <p> Identifies the current state of the user interaction. Amazon Lex returns one of the following\n   *       values as <code>dialogState</code>. The client can optionally use this information to\n   *       customize the user interface. </p>\n   *          <ul>\n   *             <li>\n   *                <p>\n   *                   <code>ElicitIntent</code> - Amazon Lex wants to elicit user intent. </p>\n   *                <p>For example, a user might utter an intent (\"I want to order a pizza\"). If Amazon Lex cannot\n   *           infer the user intent from this utterance, it will return this dialogState.</p>\n   *             </li>\n   *             <li>\n   *                <p>\n   *                   <code>ConfirmIntent</code> - Amazon Lex is expecting a \"yes\" or \"no\" response. </p>\n   *                <p> For example, Amazon Lex wants user confirmation before fulfilling an intent. </p>\n   *                <p>Instead of a simple \"yes\" or \"no,\" a user might respond with additional information.\n   *           For example, \"yes, but make it thick crust pizza\" or \"no, I want to order a drink\".\n   *           Amazon Lex can process such additional information (in these examples, update the crust\n   *           type slot value, or change intent from OrderPizza to OrderDrink).</p>\n   *             </li>\n   *             <li>\n   *                <p>\n   *                   <code>ElicitSlot</code> - Amazon Lex is expecting a slot value for the current intent. </p>\n   *                <p>For example, suppose that in the response Amazon Lex sends this message: \"What size pizza\n   *           would you like?\". A user might reply with the slot value (e.g., \"medium\"). The user might\n   *           also provide additional information in the response (e.g., \"medium thick crust pizza\").\n   *           Amazon Lex can process such additional information appropriately. </p>\n   *             </li>\n   *             <li>\n   *                <p>\n   *                   <code>Fulfilled</code> - Conveys that the Lambda function configured for the intent has\n   *           successfully fulfilled the intent. </p>\n   *\n   *             </li>\n   *             <li>\n   *                <p>\n   *                   <code>ReadyForFulfillment</code> - Conveys that the client has to fulfill the intent.\n   *         </p>\n   *             </li>\n   *             <li>\n   *                <p>\n   *                   <code>Failed</code> - Conveys that the conversation with the user failed. </p>\n   *                <p> This can happen for various reasons including that the user did not provide an\n   *           appropriate response to prompts from the service (you can configure how many times Amazon Lex\n   *           can prompt a user for specific information), or the Lambda function failed to fulfill the\n   *           intent. </p>\n   *             </li>\n   *          </ul>\n   */\n  dialogState?: DialogState | string;\n\n  /**\n   * <p>If the <code>dialogState</code> value is <code>ElicitSlot</code>, returns the name of the\n   *       slot for which Amazon Lex is eliciting a value. </p>\n   */\n  slotToElicit?: string;\n\n  /**\n   * <p>Represents the options that the user has to respond to the current prompt. Response Card\n   *       can come from the bot configuration (in the Amazon Lex console, choose the settings button next\n   *       to a slot) or from a code hook (Lambda function). </p>\n   */\n  responseCard?: ResponseCard;\n\n  /**\n   * <p>A unique identifier for the session.</p>\n   */\n  sessionId?: string;\n\n  /**\n   * <p>The version of the bot that responded to the conversation. You can use this information to\n   *       help determine if one version of a bot is performing better than another version.</p>\n   */\n  botVersion?: string;\n\n  /**\n   * <p>A list of active contexts for the session. A context can be set when an intent\n   *       is fulfilled or by calling the <code>PostContent</code>, <code>PostText</code>,\n   *       or <code>PutSession</code> operation.</p>\n   *          <p>You can use a context to control the intents that can follow up an intent,\n   *       or to modify the operation of your application.</p>\n   */\n  activeContexts?: ActiveContext[];\n}\n\nexport namespace PostTextResponse {\n  export const filterSensitiveLog = (obj: PostTextResponse): any => ({\n    ...obj,\n    ...(obj.alternativeIntents && {\n      alternativeIntents: obj.alternativeIntents.map((item) => PredictedIntent.filterSensitiveLog(item)),\n    }),\n    ...(obj.slots && { slots: SENSITIVE_STRING }),\n    ...(obj.sessionAttributes && { sessionAttributes: SENSITIVE_STRING }),\n    ...(obj.message && { message: SENSITIVE_STRING }),\n    ...(obj.activeContexts && { activeContexts: SENSITIVE_STRING }),\n  });\n}\n\nexport interface PutSessionRequest {\n  /**\n   * <p>The name of the bot that contains the session data.</p>\n   */\n  botName: string | undefined;\n\n  /**\n   * <p>The alias in use for the bot that contains the session data.</p>\n   */\n  botAlias: string | undefined;\n\n  /**\n   * <p>The ID of the client application user. Amazon Lex uses this to identify a user's conversation\n   *       with your bot. </p>\n   */\n  userId: string | undefined;\n\n  /**\n   * <p>Map of key/value pairs representing the session-specific context information. It contains\n   *       application information passed between Amazon Lex and a client application.</p>\n   */\n  sessionAttributes?: { [key: string]: string };\n\n  /**\n   * <p>Sets the next action that the bot should take to fulfill the conversation.</p>\n   */\n  dialogAction?: DialogAction;\n\n  /**\n   * <p>A summary of the recent intents for the bot. You can use the intent summary view to set a\n   *       checkpoint label on an intent and modify attributes of intents. You can also use it to remove\n   *       or add intent summary objects to the list.</p>\n   *          <p>An intent that you modify or add to the list must make sense for the bot. For example, the\n   *       intent name must be valid for the bot. You must provide valid values for:</p>\n   *          <ul>\n   *             <li>\n   *                <p>\n   *                   <code>intentName</code>\n   *                </p>\n   *             </li>\n   *             <li>\n   *                <p>slot names</p>\n   *             </li>\n   *             <li>\n   *                <p>\n   *                   <code>slotToElict</code>\n   *                </p>\n   *             </li>\n   *          </ul>\n   *          <p>If you send the <code>recentIntentSummaryView</code> parameter in a\n   *         <code>PutSession</code> request, the contents of the new summary view replaces the old\n   *       summary view. For example, if a <code>GetSession</code> request returns three intents in the\n   *       summary view and you call <code>PutSession</code> with one intent in the summary view, the\n   *       next call to <code>GetSession</code> will only return one intent.</p>\n   */\n  recentIntentSummaryView?: IntentSummary[];\n\n  /**\n   * <p>The message that Amazon Lex returns in the response can be either text or speech based\n   *       depending on the value of this field.</p>\n   *          <ul>\n   *             <li>\n   *                <p>If the value is <code>text/plain; charset=utf-8</code>, Amazon Lex returns text in the\n   *           response.</p>\n   *             </li>\n   *             <li>\n   *                <p>If the value begins with <code>audio/</code>, Amazon Lex returns speech in the response.\n   *           Amazon Lex uses Amazon Polly to generate the speech in the configuration that you specify. For\n   *           example, if you specify <code>audio/mpeg</code> as the value, Amazon Lex returns speech in the\n   *           MPEG format.</p>\n   *             </li>\n   *             <li>\n   *                <p>If the value is <code>audio/pcm</code>, the speech is returned as\n   *             <code>audio/pcm</code> in 16-bit, little endian format.</p>\n   *             </li>\n   *             <li>\n   *                <p>The following are the accepted values:</p>\n   *                <ul>\n   *                   <li>\n   *                      <p>\n   *                         <code>audio/mpeg</code>\n   *                      </p>\n   *                   </li>\n   *                   <li>\n   *                      <p>\n   *                         <code>audio/ogg</code>\n   *                      </p>\n   *                   </li>\n   *                   <li>\n   *                      <p>\n   *                         <code>audio/pcm</code>\n   *                      </p>\n   *                   </li>\n   *                   <li>\n   *                      <p>\n   *                         <code>audio/*</code> (defaults to mpeg)</p>\n   *                   </li>\n   *                   <li>\n   *                      <p>\n   *                         <code>text/plain; charset=utf-8</code>\n   *                      </p>\n   *                   </li>\n   *                </ul>\n   *             </li>\n   *          </ul>\n   */\n  accept?: string;\n\n  /**\n   * <p>A list of contexts active for the request. A context can be activated when a previous\n   *       intent is fulfilled, or by including the context in the request,</p>\n   *          <p>If you don't specify a list of contexts, Amazon Lex will use the current list of contexts for\n   *       the session. If you specify an empty list, all contexts for the session are cleared.</p>\n   */\n  activeContexts?: ActiveContext[];\n}\n\nexport namespace PutSessionRequest {\n  export const filterSensitiveLog = (obj: PutSessionRequest): any => ({\n    ...obj,\n    ...(obj.sessionAttributes && { sessionAttributes: SENSITIVE_STRING }),\n    ...(obj.dialogAction && { dialogAction: DialogAction.filterSensitiveLog(obj.dialogAction) }),\n    ...(obj.recentIntentSummaryView && {\n      recentIntentSummaryView: obj.recentIntentSummaryView.map((item) => IntentSummary.filterSensitiveLog(item)),\n    }),\n    ...(obj.activeContexts && { activeContexts: SENSITIVE_STRING }),\n  });\n}\n\nexport interface PutSessionResponse {\n  /**\n   * <p>Content type as specified in the <code>Accept</code> HTTP header in the request.</p>\n   */\n  contentType?: string;\n\n  /**\n   * <p>The name of the current intent.</p>\n   */\n  intentName?: string;\n\n  /**\n   * <p>Map of zero or more intent slots Amazon Lex detected from the user input during the\n   *       conversation.</p>\n   *          <p>Amazon Lex creates a resolution list containing likely values for a slot. The value that it\n   *       returns is determined by the <code>valueSelectionStrategy</code> selected when the slot type\n   *       was created or updated. If <code>valueSelectionStrategy</code> is set to\n   *         <code>ORIGINAL_VALUE</code>, the value provided by the user is returned, if the user value\n   *       is similar to the slot values. If <code>valueSelectionStrategy</code> is set to\n   *         <code>TOP_RESOLUTION</code> Amazon Lex returns the first value in the resolution list or, if\n   *       there is no resolution list, null. If you don't specify a <code>valueSelectionStrategy</code>\n   *       the default is <code>ORIGINAL_VALUE</code>. </p>\n   */\n  slots?: __LazyJsonString | string;\n\n  /**\n   * <p>Map of key/value pairs representing session-specific context information.</p>\n   */\n  sessionAttributes?: __LazyJsonString | string;\n\n  /**\n   * <p>The next message that should be presented to the user.</p>\n   */\n  message?: string;\n\n  /**\n   * <p>The format of the response message. One of the following values:</p>\n   *          <ul>\n   *             <li>\n   *                <p>\n   *                   <code>PlainText</code> - The message contains plain UTF-8 text.</p>\n   *             </li>\n   *             <li>\n   *                <p>\n   *                   <code>CustomPayload</code> - The message is a custom format for the client.</p>\n   *             </li>\n   *             <li>\n   *                <p>\n   *                   <code>SSML</code> - The message contains text formatted for voice output.</p>\n   *             </li>\n   *             <li>\n   *                <p>\n   *                   <code>Composite</code> - The message contains an escaped JSON object containing one or\n   *           more messages from the groups that messages were assigned to when the intent was\n   *           created.</p>\n   *             </li>\n   *          </ul>\n   */\n  messageFormat?: MessageFormatType | string;\n\n  /**\n   * <p></p>\n   *          <ul>\n   *             <li>\n   *                <p>\n   *                   <code>ConfirmIntent</code> - Amazon Lex is expecting a \"yes\" or \"no\" response to confirm\n   *           the intent before fulfilling an intent.</p>\n   *             </li>\n   *             <li>\n   *                <p>\n   *                   <code>ElicitIntent</code> - Amazon Lex wants to elicit the user's intent.</p>\n   *             </li>\n   *             <li>\n   *                <p>\n   *                   <code>ElicitSlot</code> - Amazon Lex is expecting the value of a slot for the current\n   *           intent.</p>\n   *             </li>\n   *             <li>\n   *                <p>\n   *                   <code>Failed</code> - Conveys that the conversation with the user has failed. This can\n   *           happen for various reasons, including the user does not provide an appropriate response to\n   *           prompts from the service, or if the Lambda function fails to fulfill the intent.</p>\n   *             </li>\n   *             <li>\n   *                <p>\n   *                   <code>Fulfilled</code> - Conveys that the Lambda function has sucessfully fulfilled the\n   *           intent.</p>\n   *             </li>\n   *             <li>\n   *                <p>\n   *                   <code>ReadyForFulfillment</code> - Conveys that the client has to fulfill the\n   *           intent.</p>\n   *             </li>\n   *          </ul>\n   */\n  dialogState?: DialogState | string;\n\n  /**\n   * <p>If the <code>dialogState</code> is <code>ElicitSlot</code>, returns the name of the slot\n   *       for which Amazon Lex is eliciting a value.</p>\n   */\n  slotToElicit?: string;\n\n  /**\n   * <p>The audio version of the message to convey to the user.</p>\n   */\n  audioStream?: Readable | ReadableStream | Blob;\n\n  /**\n   * <p>A unique identifier for the session.</p>\n   */\n  sessionId?: string;\n\n  /**\n   * <p>A list of active contexts for the session.</p>\n   */\n  activeContexts?: __LazyJsonString | string;\n}\n\nexport namespace PutSessionResponse {\n  export const filterSensitiveLog = (obj: PutSessionResponse): any => ({\n    ...obj,\n    ...(obj.message && { message: SENSITIVE_STRING }),\n    ...(obj.activeContexts && { activeContexts: SENSITIVE_STRING }),\n  });\n}\n"]},"metadata":{},"sourceType":"module"}