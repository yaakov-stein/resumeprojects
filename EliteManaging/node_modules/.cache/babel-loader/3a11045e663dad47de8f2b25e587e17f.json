{"ast":null,"code":"var __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nvar __generator = this && this.__generator || function (thisArg, body) {\n  var _ = {\n    label: 0,\n    sent: function () {\n      if (t[0] & 1) throw t[1];\n      return t[1];\n    },\n    trys: [],\n    ops: []\n  },\n      f,\n      y,\n      t,\n      g;\n  return g = {\n    next: verb(0),\n    \"throw\": verb(1),\n    \"return\": verb(2)\n  }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function () {\n    return this;\n  }), g;\n\n  function verb(n) {\n    return function (v) {\n      return step([n, v]);\n    };\n  }\n\n  function step(op) {\n    if (f) throw new TypeError(\"Generator is already executing.\");\n\n    while (_) try {\n      if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n      if (y = 0, t) op = [op[0] & 2, t.value];\n\n      switch (op[0]) {\n        case 0:\n        case 1:\n          t = op;\n          break;\n\n        case 4:\n          _.label++;\n          return {\n            value: op[1],\n            done: false\n          };\n\n        case 5:\n          _.label++;\n          y = op[1];\n          op = [0];\n          continue;\n\n        case 7:\n          op = _.ops.pop();\n\n          _.trys.pop();\n\n          continue;\n\n        default:\n          if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {\n            _ = 0;\n            continue;\n          }\n\n          if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {\n            _.label = op[1];\n            break;\n          }\n\n          if (op[0] === 6 && _.label < t[1]) {\n            _.label = t[1];\n            t = op;\n            break;\n          }\n\n          if (t && _.label < t[2]) {\n            _.label = t[2];\n\n            _.ops.push(op);\n\n            break;\n          }\n\n          if (t[2]) _.ops.pop();\n\n          _.trys.pop();\n\n          continue;\n      }\n\n      op = body.call(thisArg, _);\n    } catch (e) {\n      op = [6, e];\n      y = 0;\n    } finally {\n      f = t = 0;\n    }\n\n    if (op[0] & 5) throw op[1];\n    return {\n      value: op[0] ? op[1] : void 0,\n      done: true\n    };\n  }\n};\n\nvar __read = this && this.__read || function (o, n) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n  if (!m) return o;\n  var i = m.call(o),\n      r,\n      ar = [],\n      e;\n\n  try {\n    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n  } catch (error) {\n    e = {\n      error: error\n    };\n  } finally {\n    try {\n      if (r && !r.done && (m = i[\"return\"])) m.call(i);\n    } finally {\n      if (e) throw e.error;\n    }\n  }\n\n  return ar;\n};\n\nvar __spread = this && this.__spread || function () {\n  for (var ar = [], i = 0; i < arguments.length; i++) ar = ar.concat(__read(arguments[i]));\n\n  return ar;\n};\n\nimport { UploadPartCommand, CompleteMultipartUploadCommand, AbortMultipartUploadCommand, ListPartsCommand, CreateMultipartUploadCommand, ListObjectsV2Command } from '@aws-sdk/client-s3';\nimport axios from 'axios';\nimport { Logger } from '@aws-amplify/core';\nimport { byteLength, isFile } from '../common/StorageUtils';\nimport { AWSS3ProviderUploadErrorStrings } from '../common/StorageErrorStrings';\nimport { SET_CONTENT_LENGTH_HEADER, UPLOADS_STORAGE_KEY } from '../common/StorageConstants';\nvar logger = new Logger('AWSS3UploadTask');\nexport var AWSS3UploadTaskState;\n\n(function (AWSS3UploadTaskState) {\n  AWSS3UploadTaskState[AWSS3UploadTaskState[\"INIT\"] = 0] = \"INIT\";\n  AWSS3UploadTaskState[AWSS3UploadTaskState[\"IN_PROGRESS\"] = 1] = \"IN_PROGRESS\";\n  AWSS3UploadTaskState[AWSS3UploadTaskState[\"PAUSED\"] = 2] = \"PAUSED\";\n  AWSS3UploadTaskState[AWSS3UploadTaskState[\"CANCELLED\"] = 3] = \"CANCELLED\";\n  AWSS3UploadTaskState[AWSS3UploadTaskState[\"COMPLETED\"] = 4] = \"COMPLETED\";\n})(AWSS3UploadTaskState || (AWSS3UploadTaskState = {}));\n\nexport var TaskEvents;\n\n(function (TaskEvents) {\n  TaskEvents[\"CANCEL\"] = \"cancel\";\n  TaskEvents[\"UPLOAD_COMPLETE\"] = \"uploadComplete\";\n  TaskEvents[\"UPLOAD_PROGRESS\"] = \"uploadPartProgress\";\n  TaskEvents[\"ERROR\"] = \"error\";\n})(TaskEvents || (TaskEvents = {})); // maximum number of parts per upload request according the S3 spec,\n// see: https://docs.aws.amazon.com/AmazonS3/latest/userguide/qfacts.html\n\n\nvar MAX_PARTS = 10000; // 5MB in bytes\n\nvar PART_SIZE = 5 * 1024 * 1024;\nvar DEFAULT_QUEUE_SIZE = 4;\n\nfunction comparePartNumber(a, b) {\n  return a.PartNumber - b.PartNumber;\n}\n\nvar AWSS3UploadTask =\n/** @class */\nfunction () {\n  function AWSS3UploadTask(_a) {\n    var s3Client = _a.s3Client,\n        file = _a.file,\n        emitter = _a.emitter,\n        storage = _a.storage,\n        params = _a.params,\n        level = _a.level,\n        prefixPromise = _a.prefixPromise;\n    this.partSize = PART_SIZE;\n    this.queueSize = DEFAULT_QUEUE_SIZE;\n    this.inProgress = [];\n    this.completedParts = [];\n    this.queued = [];\n    this.bytesUploaded = 0;\n    this.totalBytes = 0;\n    this.state = AWSS3UploadTaskState.INIT;\n    this.prefixPromise = prefixPromise;\n    this.s3client = s3Client;\n    this.s3client.middlewareStack.remove(SET_CONTENT_LENGTH_HEADER);\n    this.storage = storage;\n    this.storageSync = Promise.resolve();\n\n    if (typeof this.storage['sync'] === 'function') {\n      this.storageSync = this.storage['sync']();\n    }\n\n    this.params = params;\n    this.file = file;\n    this.totalBytes = this.file.size;\n    this.bytesUploaded = 0;\n    this.emitter = emitter;\n    this.queued = [];\n    this.fileId = this._getFileId(level);\n\n    this._validateParams(); // event emitter will re-throw an error if an event emits an error unless there's a listener, attaching a no-op\n    // function to it unless user adds their own onError callback\n\n\n    this.emitter.on(TaskEvents.ERROR, function () {});\n  }\n\n  Object.defineProperty(AWSS3UploadTask.prototype, \"percent\", {\n    get: function () {\n      return this.bytesUploaded / this.totalBytes * 100;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(AWSS3UploadTask.prototype, \"isInProgress\", {\n    get: function () {\n      return this.state === AWSS3UploadTaskState.IN_PROGRESS;\n    },\n    enumerable: true,\n    configurable: true\n  });\n\n  AWSS3UploadTask.prototype._listSingleFile = function (_a) {\n    var key = _a.key,\n        bucket = _a.bucket;\n    return __awaiter(this, void 0, void 0, function () {\n      var listObjectRes, _b, Contents, prefix, obj;\n\n      return __generator(this, function (_c) {\n        switch (_c.label) {\n          case 0:\n            return [4\n            /*yield*/\n            , this.s3client.send(new ListObjectsV2Command({\n              Bucket: bucket,\n              Prefix: key\n            }))];\n\n          case 1:\n            listObjectRes = _c.sent();\n            _b = listObjectRes.Contents, Contents = _b === void 0 ? [] : _b;\n            return [4\n            /*yield*/\n            , this.prefixPromise];\n\n          case 2:\n            prefix = _c.sent();\n            obj = Contents.find(function (o) {\n              return o.Key === \"\" + prefix + key;\n            });\n            return [2\n            /*return*/\n            , obj];\n        }\n      });\n    });\n  };\n\n  AWSS3UploadTask.prototype._getFileId = function (level) {\n    // We should check if it's a File first because File is also instance of a Blob\n    if (isFile(this.file)) {\n      return [this.file.name, this.file.lastModified, this.file.size, this.file.type, this.params.Bucket, level, this.params.Key].join('-');\n    } else {\n      return [this.file.size, this.file.type, this.params.Bucket, level, this.params.Key].join('-');\n    }\n  };\n\n  AWSS3UploadTask.prototype._findCachedUploadParts = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      var uploadRequests, cachedUploadFileData, listPartsOutput;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            return [4\n            /*yield*/\n            , this._listCachedUploadTasks()];\n\n          case 1:\n            uploadRequests = _a.sent();\n\n            if (Object.keys(uploadRequests).length === 0 || !Object.prototype.hasOwnProperty.call(uploadRequests, this.fileId)) {\n              return [2\n              /*return*/\n              , {\n                parts: [],\n                uploadId: null\n              }];\n            }\n\n            cachedUploadFileData = uploadRequests[this.fileId];\n            cachedUploadFileData.lastTouched = Date.now();\n            this.storage.setItem(UPLOADS_STORAGE_KEY, JSON.stringify(uploadRequests));\n            return [4\n            /*yield*/\n            , this.s3client.send(new ListPartsCommand({\n              Bucket: this.params.Bucket,\n              Key: this.params.Key,\n              UploadId: cachedUploadFileData.uploadId\n            }))];\n\n          case 2:\n            listPartsOutput = _a.sent();\n            return [2\n            /*return*/\n            , {\n              parts: listPartsOutput.Parts || [],\n              uploadId: cachedUploadFileData.uploadId\n            }];\n        }\n      });\n    });\n  };\n\n  AWSS3UploadTask.prototype._emitEvent = function (event, payload) {\n    this.emitter.emit(event, payload);\n  };\n\n  AWSS3UploadTask.prototype._validateParams = function () {\n    if (this.file.size / this.partSize > MAX_PARTS) {\n      throw new Error(\"Too many parts. Number of parts is \" + this.file.size / this.partSize + \", maximum is \" + MAX_PARTS + \".\");\n    }\n  };\n\n  AWSS3UploadTask.prototype._listCachedUploadTasks = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      var tasks;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            return [4\n            /*yield*/\n            , this.storageSync];\n\n          case 1:\n            _a.sent();\n\n            tasks = this.storage.getItem(UPLOADS_STORAGE_KEY) || '{}';\n            return [2\n            /*return*/\n            , JSON.parse(tasks)];\n        }\n      });\n    });\n  };\n\n  AWSS3UploadTask.prototype._cache = function (fileMetadata) {\n    return __awaiter(this, void 0, void 0, function () {\n      var uploadRequests;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            return [4\n            /*yield*/\n            , this._listCachedUploadTasks()];\n\n          case 1:\n            uploadRequests = _a.sent();\n            uploadRequests[this.fileId] = fileMetadata;\n            this.storage.setItem(UPLOADS_STORAGE_KEY, JSON.stringify(uploadRequests));\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  };\n\n  AWSS3UploadTask.prototype._isCached = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      var _a, _b;\n\n      return __generator(this, function (_c) {\n        switch (_c.label) {\n          case 0:\n            _b = (_a = Object.prototype.hasOwnProperty).call;\n            return [4\n            /*yield*/\n            , this._listCachedUploadTasks()];\n\n          case 1:\n            return [2\n            /*return*/\n            , _b.apply(_a, [_c.sent(), this.fileId])];\n        }\n      });\n    });\n  };\n\n  AWSS3UploadTask.prototype._removeFromCache = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      var uploadRequests;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            return [4\n            /*yield*/\n            , this._listCachedUploadTasks()];\n\n          case 1:\n            uploadRequests = _a.sent();\n            delete uploadRequests[this.fileId];\n            this.storage.setItem(UPLOADS_STORAGE_KEY, JSON.stringify(uploadRequests));\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  };\n\n  AWSS3UploadTask.prototype._onPartUploadCompletion = function (_a) {\n    var eTag = _a.eTag,\n        partNumber = _a.partNumber,\n        chunk = _a.chunk;\n    return __awaiter(this, void 0, void 0, function () {\n      return __generator(this, function (_b) {\n        this.completedParts.push({\n          ETag: eTag,\n          PartNumber: partNumber\n        });\n        this.bytesUploaded += byteLength(chunk);\n\n        this._emitEvent(TaskEvents.UPLOAD_PROGRESS, {\n          loaded: this.bytesUploaded,\n          total: this.totalBytes\n        }); // Remove the completed item from the inProgress array\n\n\n        this.inProgress = this.inProgress.filter(function (job) {\n          return job.uploadPartInput.PartNumber !== partNumber;\n        });\n        if (this.queued.length && this.state !== AWSS3UploadTaskState.PAUSED) this._startNextPart();\n        if (this._isDone()) this._completeUpload();\n        return [2\n        /*return*/\n        ];\n      });\n    });\n  };\n\n  AWSS3UploadTask.prototype._completeUpload = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      var err_1;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            _a.trys.push([0, 2,, 3]);\n\n            return [4\n            /*yield*/\n            , this.s3client.send(new CompleteMultipartUploadCommand({\n              Bucket: this.params.Bucket,\n              Key: this.params.Key,\n              UploadId: this.uploadId,\n              MultipartUpload: {\n                // Parts are not always completed in order, we need to manually sort them\n                Parts: this.completedParts.sort(comparePartNumber)\n              }\n            }))];\n\n          case 1:\n            _a.sent();\n\n            this._verifyFileSize();\n\n            this._emitEvent(TaskEvents.UPLOAD_COMPLETE, {\n              key: this.params.Bucket + \"/\" + this.params.Key\n            });\n\n            this._removeFromCache();\n\n            this.state = AWSS3UploadTaskState.COMPLETED;\n            return [3\n            /*break*/\n            , 3];\n\n          case 2:\n            err_1 = _a.sent();\n            logger.error('error completing upload', err_1);\n\n            this._emitEvent(TaskEvents.ERROR, err_1);\n\n            return [3\n            /*break*/\n            , 3];\n\n          case 3:\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  };\n\n  AWSS3UploadTask.prototype._makeUploadPartRequest = function (input, cancelTokenSource) {\n    return __awaiter(this, void 0, void 0, function () {\n      var res, err_2;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            _a.trys.push([0, 3,, 4]);\n\n            return [4\n            /*yield*/\n            , this.s3client.send(new UploadPartCommand(input), {\n              cancelTokenSource: cancelTokenSource\n            })];\n\n          case 1:\n            res = _a.sent();\n            return [4\n            /*yield*/\n            , this._onPartUploadCompletion({\n              eTag: res.ETag,\n              partNumber: input.PartNumber,\n              chunk: input.Body\n            })];\n\n          case 2:\n            _a.sent();\n\n            return [3\n            /*break*/\n            , 4];\n\n          case 3:\n            err_2 = _a.sent();\n\n            if (this.state === AWSS3UploadTaskState.PAUSED) {\n              logger.log('upload paused');\n            } else if (this.state === AWSS3UploadTaskState.CANCELLED) {\n              logger.log('upload aborted');\n            } else {\n              logger.error('error starting next part of upload: ', err_2);\n            } // axios' cancel will also throw an error, however we don't need to emit an event in that case as it's an\n            // expected behavior\n\n\n            if (!axios.isCancel(err_2) && err_2.message !== AWSS3ProviderUploadErrorStrings.UPLOAD_PAUSED_MESSAGE) {\n              this._emitEvent(TaskEvents.ERROR, err_2);\n\n              this.pause();\n            }\n\n            return [3\n            /*break*/\n            , 4];\n\n          case 4:\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  };\n\n  AWSS3UploadTask.prototype._startNextPart = function () {\n    if (this.queued.length > 0 && this.state !== AWSS3UploadTaskState.PAUSED) {\n      var cancelTokenSource = axios.CancelToken.source();\n      var nextPart = this.queued.shift();\n      this.inProgress.push({\n        uploadPartInput: nextPart,\n        s3Request: this._makeUploadPartRequest(nextPart, cancelTokenSource),\n        cancel: cancelTokenSource.cancel\n      });\n    }\n  };\n  /**\n   * Verify on S3 side that the file size matches the one on the client side.\n   *\n   * @async\n   * @throws throws an error if the file size does not match between local copy of the file and the file on s3.\n   */\n\n\n  AWSS3UploadTask.prototype._verifyFileSize = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      var obj, valid;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            return [4\n            /*yield*/\n            , this._listSingleFile({\n              key: this.params.Key,\n              bucket: this.params.Bucket\n            })];\n\n          case 1:\n            obj = _a.sent();\n            valid = Boolean(obj && obj.Size === this.file.size);\n\n            if (!valid) {\n              throw new Error('File size does not match between local file and file on s3');\n            }\n\n            return [2\n            /*return*/\n            , valid];\n        }\n      });\n    });\n  };\n\n  AWSS3UploadTask.prototype._isDone = function () {\n    return !this.queued.length && !this.inProgress.length && this.bytesUploaded === this.totalBytes;\n  };\n\n  AWSS3UploadTask.prototype._createParts = function () {\n    var size = this.file.size;\n    var parts = [];\n\n    for (var bodyStart = 0; bodyStart < size;) {\n      var bodyEnd = Math.min(bodyStart + this.partSize, size);\n      parts.push({\n        Body: this.file.slice(bodyStart, bodyEnd),\n        Key: this.params.Key,\n        Bucket: this.params.Bucket,\n        PartNumber: parts.length + 1,\n        UploadId: this.uploadId\n      });\n      bodyStart += this.partSize;\n    }\n\n    return parts;\n  };\n\n  AWSS3UploadTask.prototype._initCachedUploadParts = function (cachedParts) {\n    this.bytesUploaded += cachedParts.reduce(function (acc, part) {\n      return acc + part.Size;\n    }, 0); // Find the set of part numbers that have already been uploaded\n\n    var uploadedPartNumSet = new Set(cachedParts.map(function (part) {\n      return part.PartNumber;\n    }));\n    this.queued = this.queued.filter(function (part) {\n      return !uploadedPartNumSet.has(part.PartNumber);\n    });\n    this.completedParts = cachedParts.map(function (part) {\n      return {\n        PartNumber: part.PartNumber,\n        ETag: part.ETag\n      };\n    });\n\n    this._emitEvent(TaskEvents.UPLOAD_PROGRESS, {\n      loaded: this.bytesUploaded,\n      total: this.totalBytes\n    });\n  };\n\n  AWSS3UploadTask.prototype._initMultipartUpload = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      var res;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            return [4\n            /*yield*/\n            , this.s3client.send(new CreateMultipartUploadCommand(this.params))];\n\n          case 1:\n            res = _a.sent();\n\n            this._cache({\n              uploadId: res.UploadId,\n              lastTouched: Date.now(),\n              bucket: this.params.Bucket,\n              key: this.params.Key,\n              fileName: this.file instanceof File ? this.file.name : ''\n            });\n\n            return [2\n            /*return*/\n            , res.UploadId];\n        }\n      });\n    });\n  };\n\n  AWSS3UploadTask.prototype._initializeUploadTask = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      var _a, parts, uploadId, uploadId, err_3;\n\n      return __generator(this, function (_b) {\n        switch (_b.label) {\n          case 0:\n            this.state = AWSS3UploadTaskState.IN_PROGRESS;\n            _b.label = 1;\n\n          case 1:\n            _b.trys.push([1, 7,, 8]);\n\n            return [4\n            /*yield*/\n            , this._isCached()];\n\n          case 2:\n            if (!_b.sent()) return [3\n            /*break*/\n            , 4];\n            return [4\n            /*yield*/\n            , this._findCachedUploadParts()];\n\n          case 3:\n            _a = _b.sent(), parts = _a.parts, uploadId = _a.uploadId;\n            this.uploadId = uploadId;\n            this.queued = this._createParts();\n\n            this._initCachedUploadParts(parts);\n\n            this._startUpload();\n\n            return [3\n            /*break*/\n            , 6];\n\n          case 4:\n            if (!!this.uploadId) return [3\n            /*break*/\n            , 6];\n            return [4\n            /*yield*/\n            , this._initMultipartUpload()];\n\n          case 5:\n            uploadId = _b.sent();\n            this.uploadId = uploadId;\n            this.queued = this._createParts();\n\n            this._startUpload();\n\n            _b.label = 6;\n\n          case 6:\n            return [3\n            /*break*/\n            , 8];\n\n          case 7:\n            err_3 = _b.sent();\n\n            if (!axios.isCancel(err_3)) {\n              logger.error('Error initializing the upload task', err_3);\n            }\n\n            return [3\n            /*break*/\n            , 8];\n\n          case 8:\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  };\n\n  AWSS3UploadTask.prototype.resume = function () {\n    if (this.state === AWSS3UploadTaskState.CANCELLED) {\n      logger.warn('This task has already been cancelled');\n    } else if (this.state === AWSS3UploadTaskState.COMPLETED) {\n      logger.warn('This task has already been completed');\n    } else if (this.state === AWSS3UploadTaskState.IN_PROGRESS) {\n      logger.warn('Upload task already in progress'); // first time running resume, find any cached parts on s3 or start a new multipart upload request before\n      // starting the upload\n    } else if (!this.uploadId) {\n      this._initializeUploadTask();\n    } else {\n      this._startUpload();\n    }\n  };\n\n  AWSS3UploadTask.prototype._startUpload = function () {\n    this.state = AWSS3UploadTaskState.IN_PROGRESS;\n\n    for (var i = 0; i < this.queueSize; i++) {\n      this._startNextPart();\n    }\n  };\n\n  AWSS3UploadTask.prototype._cancel = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      var err_4;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            if (!(this.state === AWSS3UploadTaskState.CANCELLED)) return [3\n            /*break*/\n            , 1];\n            logger.warn('This task has already been cancelled');\n            return [2\n            /*return*/\n            , false];\n\n          case 1:\n            if (!(this.state === AWSS3UploadTaskState.COMPLETED)) return [3\n            /*break*/\n            , 2];\n            logger.warn('This task has already been completed');\n            return [2\n            /*return*/\n            , false];\n\n          case 2:\n            this.pause();\n            this.queued = [];\n            this.completedParts = [];\n            this.bytesUploaded = 0;\n            this.state = AWSS3UploadTaskState.CANCELLED;\n            _a.label = 3;\n\n          case 3:\n            _a.trys.push([3, 6,, 7]);\n\n            return [4\n            /*yield*/\n            , this.s3client.send(new AbortMultipartUploadCommand({\n              Bucket: this.params.Bucket,\n              Key: this.params.Key,\n              UploadId: this.uploadId\n            }))];\n\n          case 4:\n            _a.sent();\n\n            return [4\n            /*yield*/\n            , this._removeFromCache()];\n\n          case 5:\n            _a.sent();\n\n            return [2\n            /*return*/\n            , true];\n\n          case 6:\n            err_4 = _a.sent();\n            logger.error('Error cancelling upload task', err_4);\n            return [2\n            /*return*/\n            , false];\n\n          case 7:\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  };\n  /**\n   * pause this particular upload task\n   **/\n\n\n  AWSS3UploadTask.prototype.pause = function () {\n    var _a;\n\n    if (this.state === AWSS3UploadTaskState.CANCELLED) {\n      logger.warn('This task has already been cancelled');\n    } else if (this.state === AWSS3UploadTaskState.COMPLETED) {\n      logger.warn('This task has already been completed');\n    } else if (this.state === AWSS3UploadTaskState.PAUSED) {\n      logger.warn('This task is already paused');\n    }\n\n    this.state = AWSS3UploadTaskState.PAUSED; // Use axios cancel token to abort the part request immediately\n    // Add the inProgress parts back to pending\n\n    var removedInProgressReq = this.inProgress.splice(0, this.inProgress.length);\n    removedInProgressReq.forEach(function (req) {\n      req.cancel(AWSS3ProviderUploadErrorStrings.UPLOAD_PAUSED_MESSAGE);\n    }); // Put all removed in progress parts back into the queue\n\n    (_a = this.queued).unshift.apply(_a, __spread(removedInProgressReq.map(function (req) {\n      return req.uploadPartInput;\n    })));\n  };\n\n  return AWSS3UploadTask;\n}();\n\nexport { AWSS3UploadTask };","map":{"version":3,"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA,SAICA,iBAJD,EAKCC,8BALD,EAOCC,2BAPD,EAQCC,gBARD,EASCC,4BATD,EAWCC,oBAXD,QAYO,oBAZP;AAcA,OAAOC,KAAP,MAAmD,OAAnD;AAEA,SAASC,MAAT,QAAuB,mBAAvB;AAEA,SAASC,UAAT,EAAqBC,MAArB,QAAmC,wBAAnC;AACA,SAASC,+BAAT,QAAgD,+BAAhD;AACA,SACCC,yBADD,EAECC,mBAFD,QAGO,4BAHP;AAMA,IAAMC,MAAM,GAAG,IAAIN,MAAJ,CAAW,iBAAX,CAAf;AACA,WAAYO,oBAAZ;;AAAA,WAAYA,oBAAZ,EAAgC;EAC/BA;EACAA;EACAA;EACAA;EACAA;AACA,CAND,EAAYA,oBAAoB,KAApBA,oBAAoB,MAAhC;;AAQA,WAAYC,UAAZ;;AAAA,WAAYA,UAAZ,EAAsB;EACrBA;EACAA;EACAA;EACAA;AACA,CALD,EAAYA,UAAU,KAAVA,UAAU,MAAtB,E,CA+CA;AACA;;;AACA,IAAMC,SAAS,GAAG,KAAlB,C,CACA;;AACA,IAAMC,SAAS,GAAG,IAAI,IAAJ,GAAW,IAA7B;AACA,IAAMC,kBAAkB,GAAG,CAA3B;;AAEA,SAASC,iBAAT,CAA2BC,CAA3B,EAA6CC,CAA7C,EAA6D;EAC5D,OAAOD,CAAC,CAACE,UAAF,GAAeD,CAAC,CAACC,UAAxB;AACA;;AAED;AAAA;AAAA;EAoBC,yBAAYC,EAAZ,EAQwB;QAPvBC;QACAC;QACAC;QACAC;QACAC;QACAC;QACAC;IAxBgB,gBAAmBb,SAAnB;IACA,iBAAYC,kBAAZ;IAOT,kBAAkC,EAAlC;IACA,sBAAkC,EAAlC;IACA,cAAmC,EAAnC;IACA,qBAAwB,CAAxB;IACA,kBAAqB,CAArB;IAGD,aAA8BJ,oBAAoB,CAACiB,IAAnD;IAWN,KAAKD,aAAL,GAAqBA,aAArB;IACA,KAAKE,QAAL,GAAgBR,QAAhB;IACA,KAAKQ,QAAL,CAAcC,eAAd,CAA8BC,MAA9B,CAAqCvB,yBAArC;IACA,KAAKgB,OAAL,GAAeA,OAAf;IACA,KAAKQ,WAAL,GAAmBC,OAAO,CAACC,OAAR,EAAnB;;IACA,IAAI,OAAO,KAAKV,OAAL,CAAa,MAAb,CAAP,KAAgC,UAApC,EAAgD;MAC/C,KAAKQ,WAAL,GAAmB,KAAKR,OAAL,CAAa,MAAb,GAAnB;IACA;;IACD,KAAKC,MAAL,GAAcA,MAAd;IACA,KAAKH,IAAL,GAAYA,IAAZ;IACA,KAAKa,UAAL,GAAkB,KAAKb,IAAL,CAAUc,IAA5B;IACA,KAAKC,aAAL,GAAqB,CAArB;IACA,KAAKd,OAAL,GAAeA,OAAf;IACA,KAAKe,MAAL,GAAc,EAAd;IACA,KAAKC,MAAL,GAAc,KAAKC,UAAL,CAAgBd,KAAhB,CAAd;;IACA,KAAKe,eAAL,GAhBuB,CAiBvB;IACA;;;IACA,KAAKlB,OAAL,CAAamB,EAAb,CAAgB9B,UAAU,CAAC+B,KAA3B,EAAkC,aAAQ,CAA1C;EACA;;EAEDC,sBAAIC,yBAAJ,EAAI,SAAJ,EAAW;SAAX;MACC,OAAQ,KAAKR,aAAL,GAAqB,KAAKF,UAA3B,GAAyC,GAAhD;IACA,CAFU;oBAAA;;EAAA,CAAX;EAIAS,sBAAIC,yBAAJ,EAAI,cAAJ,EAAgB;SAAhB;MACC,OAAO,KAAKC,KAAL,KAAenC,oBAAoB,CAACoC,WAA3C;IACA,CAFe;oBAAA;;EAAA,CAAhB;;EAIcF,4CAAd,UAA8BzB,EAA9B,EAMC;QALA4B;QACAC;;;;;;;YAKsB;YAAA;YAAA,EAAM,KAAKpB,QAAL,CAAcqB,IAAd,CAC3B,IAAIhD,oBAAJ,CAAyB;cACxBiD,MAAM,EAAEF,MADgB;cAExBG,MAAM,EAAEJ;YAFgB,CAAzB,CAD2B,CAAN;;;YAAhBK,aAAa,GAAGC,SAAhB;YAMEC,KAAkBF,aAAa,SAA/B,UAAQ,mBAAG,EAAH,GAAKE,EAAb;YACO;YAAA;YAAA,EAAM,KAAK5B,aAAX;;;YAAT6B,MAAM,GAAGF,SAAT;YACAG,GAAG,GAAGC,QAAQ,CAACC,IAAT,CAAc,aAAC;cAAI,QAAC,CAACC,GAAF,KAAU,KAAGJ,MAAH,GAAYR,GAAtB;YAA2B,CAA9C,CAAN;YACN;YAAA;YAAA,EAAOS,GAAP;;;;EACA,CAjBa;;EAmBNZ,uCAAR,UAAmBnB,KAAnB,EAA4C;IAC3C;IACA,IAAIpB,MAAM,CAAC,KAAKgB,IAAN,CAAV,EAAuB;MACtB,OAAO,CACN,KAAKA,IAAL,CAAUuC,IADJ,EAEN,KAAKvC,IAAL,CAAUwC,YAFJ,EAGN,KAAKxC,IAAL,CAAUc,IAHJ,EAIN,KAAKd,IAAL,CAAUyC,IAJJ,EAKN,KAAKtC,MAAL,CAAY0B,MALN,EAMNzB,KANM,EAON,KAAKD,MAAL,CAAYmC,GAPN,EAQLI,IARK,CAQA,GARA,CAAP;IASA,CAVD,MAUO;MACN,OAAO,CACN,KAAK1C,IAAL,CAAUc,IADJ,EAEN,KAAKd,IAAL,CAAUyC,IAFJ,EAGN,KAAKtC,MAAL,CAAY0B,MAHN,EAINzB,KAJM,EAKN,KAAKD,MAAL,CAAYmC,GALN,EAMLI,IANK,CAMA,GANA,CAAP;IAOA;EACD,CArBO;;EAuBMnB,mDAAd;;;;;;YAIwB;YAAA;YAAA,EAAM,KAAKoB,sBAAL,EAAN;;;YAAjBC,cAAc,GAAG9C,SAAjB;;YAEN,IACCwB,MAAM,CAACuB,IAAP,CAAYD,cAAZ,EAA4BE,MAA5B,KAAuC,CAAvC,IACA,CAACxB,MAAM,CAACyB,SAAP,CAAiBC,cAAjB,CAAgCC,IAAhC,CAAqCL,cAArC,EAAqD,KAAK3B,MAA1D,CAFF,EAGE;cACD;cAAA;cAAA,EAAO;gBAAEiC,KAAK,EAAE,EAAT;gBAAaC,QAAQ,EAAE;cAAvB,CAAP;YACA;;YAEKC,oBAAoB,GAAGR,cAAc,CAAC,KAAK3B,MAAN,CAArC;YACNmC,oBAAoB,CAACC,WAArB,GAAmCC,IAAI,CAACC,GAAL,EAAnC;YACA,KAAKrD,OAAL,CAAasD,OAAb,CAAqBrE,mBAArB,EAA0CsE,IAAI,CAACC,SAAL,CAAed,cAAf,CAA1C;YAEwB;YAAA;YAAA,EAAM,KAAKrC,QAAL,CAAcqB,IAAd,CAC7B,IAAIlD,gBAAJ,CAAqB;cACpBmD,MAAM,EAAE,KAAK1B,MAAL,CAAY0B,MADA;cAEpBS,GAAG,EAAE,KAAKnC,MAAL,CAAYmC,GAFG;cAGpBqB,QAAQ,EAAEP,oBAAoB,CAACD;YAHX,CAArB,CAD6B,CAAN;;;YAAlBS,eAAe,GAAG9D,SAAlB;YAQN;YAAA;YAAA,EAAO;cACNoD,KAAK,EAAEU,eAAe,CAACC,KAAhB,IAAyB,EAD1B;cAENV,QAAQ,EAAEC,oBAAoB,CAACD;YAFzB,CAAP;;;;EAIA,CA7Ba;;EA+BN5B,uCAAR,UAA4BuC,KAA5B,EAA2CC,OAA3C,EAAqD;IACpD,KAAK9D,OAAL,CAAa+D,IAAb,CAAkBF,KAAlB,EAAyBC,OAAzB;EACA,CAFO;;EAIAxC,4CAAR;IACC,IAAI,KAAKvB,IAAL,CAAUc,IAAV,GAAiB,KAAKmD,QAAtB,GAAiC1E,SAArC,EAAgD;MAC/C,MAAM,IAAI2E,KAAJ,CACL,wCAAsC,KAAKlE,IAAL,CAAUc,IAAV,GACrC,KAAKmD,QADN,GACc,eADd,GAC8B1E,SAD9B,GACuC,GAFlC,CAAN;IAIA;EACD,CAPO;;EASMgC,mDAAd;;;;;;YAGC;YAAA;YAAA,EAAM,KAAKb,WAAX;;;YAAAZ;;YACMqE,KAAK,GAAG,KAAKjE,OAAL,CAAakE,OAAb,CAAqBjF,mBAArB,KAA6C,IAArD;YACN;YAAA;YAAA,EAAOsE,IAAI,CAACY,KAAL,CAAWF,KAAX,CAAP;;;;EACA,CANa;;EAQA5C,mCAAd,UAAqB+C,YAArB,EAA+C;;;;;;YACvB;YAAA;YAAA,EAAM,KAAK3B,sBAAL,EAAN;;;YAAjBC,cAAc,GAAG9C,SAAjB;YACN8C,cAAc,CAAC,KAAK3B,MAAN,CAAd,GAA8BqD,YAA9B;YACA,KAAKpE,OAAL,CAAasD,OAAb,CAAqBrE,mBAArB,EAA0CsE,IAAI,CAACC,SAAL,CAAed,cAAf,CAA1C;;;;;;;EACA,CAJa;;EAMArB,sCAAd;;;;;;;YACQU,iBAAM,CAACc,SAAP,CAAiBC,cAAjB,EAAgCC,IAAhC;YACN;YAAA;YAAA,EAAM,KAAKN,sBAAL,EAAN;;;YADD;YAAA;YAAA,EAAOV,cACND,SADM,EAEN,KAAKf,MAFC,EAAP;;;;EAIA,CALa;;EAOAM,6CAAd;;;;;;YACwB;YAAA;YAAA,EAAM,KAAKoB,sBAAL,EAAN;;;YAAjBC,cAAc,GAAG9C,SAAjB;YACN,OAAO8C,cAAc,CAAC,KAAK3B,MAAN,CAArB;YACA,KAAKf,OAAL,CAAasD,OAAb,CAAqBrE,mBAArB,EAA0CsE,IAAI,CAACC,SAAL,CAAed,cAAf,CAA1C;;;;;;;EACA,CAJa;;EAMArB,oDAAd,UAAsCzB,EAAtC,EAQC;QAPAyE;QACAC;QACAC;;;QAMA,KAAKC,cAAL,CAAoBC,IAApB,CAAyB;UACxBC,IAAI,EAAEL,IADkB;UAExB1E,UAAU,EAAE2E;QAFY,CAAzB;QAIA,KAAKzD,aAAL,IAAsBhC,UAAU,CAAC0F,KAAD,CAAhC;;QACA,KAAKI,UAAL,CAAyCvF,UAAU,CAACwF,eAApD,EAAqE;UACpEC,MAAM,EAAE,KAAKhE,aADuD;UAEpEiE,KAAK,EAAE,KAAKnE;QAFwD,CAArE,GAIA;;;QACA,KAAKoE,UAAL,GAAkB,KAAKA,UAAL,CAAgBC,MAAhB,CACjB,eAAG;UAAI,UAAG,CAACC,eAAJ,CAAoBtF,UAApB,KAAmC2E,UAAnC;QAA6C,CADnC,CAAlB;QAGA,IAAI,KAAKxD,MAAL,CAAY8B,MAAZ,IAAsB,KAAKtB,KAAL,KAAenC,oBAAoB,CAAC+F,MAA9D,EACC,KAAKC,cAAL;QACD,IAAI,KAAKC,OAAL,EAAJ,EAAoB,KAAKC,eAAL;;;;;;EACpB,CAzBa;;EA2BAhE,4CAAd;;;;;;;;YAEE;YAAA;YAAA,EAAM,KAAKhB,QAAL,CAAcqB,IAAd,CACL,IAAIpD,8BAAJ,CAAmC;cAClCqD,MAAM,EAAE,KAAK1B,MAAL,CAAY0B,MADc;cAElCS,GAAG,EAAE,KAAKnC,MAAL,CAAYmC,GAFiB;cAGlCqB,QAAQ,EAAE,KAAKR,QAHmB;cAIlCqC,eAAe,EAAE;gBAChB;gBACA3B,KAAK,EAAE,KAAKa,cAAL,CAAoBe,IAApB,CAAyB/F,iBAAzB;cAFS;YAJiB,CAAnC,CADK,CAAN;;;YAAAI;;YAWA,KAAK4F,eAAL;;YACA,KAAKb,UAAL,CAAyCvF,UAAU,CAACqG,eAApD,EAAqE;cACpEjE,GAAG,EAAK,KAAKvB,MAAL,CAAY0B,MAAZ,GAAkB,GAAlB,GAAsB,KAAK1B,MAAL,CAAYmC;YAD0B,CAArE;;YAGA,KAAKsD,gBAAL;;YACA,KAAKpE,KAAL,GAAanC,oBAAoB,CAACwG,SAAlC;;;;;;;YAEAzG,MAAM,CAAC0G,KAAP,CAAa,yBAAb,EAAwCC,KAAxC;;YACA,KAAKlB,UAAL,CAAgBvF,UAAU,CAAC+B,KAA3B,EAAkC0E,KAAlC;;;;;;;;;;;;;EAED,CAvBa;;EAyBAxE,mDAAd,UACCyE,KADD,EAECC,iBAFD,EAEqC;;;;;;;;YAGvB;YAAA;YAAA,EAAM,KAAK1F,QAAL,CAAcqB,IAAd,CAAmB,IAAIrD,iBAAJ,CAAsByH,KAAtB,CAAnB,EAAiD;cAClEC,iBAAiB;YADiD,CAAjD,CAAN;;;YAANC,GAAG,GAAGpG,SAAN;YAGN;YAAA;YAAA,EAAM,KAAKqG,uBAAL,CAA6B;cAClC5B,IAAI,EAAE2B,GAAG,CAACtB,IADwB;cAElCJ,UAAU,EAAEwB,KAAK,CAACnG,UAFgB;cAGlC4E,KAAK,EAAEuB,KAAK,CAACI;YAHqB,CAA7B,CAAN;;;YAAAtG;;;;;;;;;YAMA,IAAI,KAAK0B,KAAL,KAAenC,oBAAoB,CAAC+F,MAAxC,EAAgD;cAC/ChG,MAAM,CAACiH,GAAP,CAAW,eAAX;YACA,CAFD,MAEO,IAAI,KAAK7E,KAAL,KAAenC,oBAAoB,CAACiH,SAAxC,EAAmD;cACzDlH,MAAM,CAACiH,GAAP,CAAW,gBAAX;YACA,CAFM,MAEA;cACNjH,MAAM,CAAC0G,KAAP,CAAa,sCAAb,EAAqDS,KAArD;YACA,EACD;YACA;;;YACA,IACC,CAAC1H,KAAK,CAAC2H,QAAN,CAAeD,KAAf,CAAD,IACAA,KAAG,CAACE,OAAJ,KAAgBxH,+BAA+B,CAACyH,qBAFjD,EAGE;cACD,KAAK7B,UAAL,CAAgBvF,UAAU,CAAC+B,KAA3B,EAAkCkF,KAAlC;;cACA,KAAKI,KAAL;YACA;;;;;;;;;;;;;EAEF,CA/Ba;;EAiCNpF,2CAAR;IACC,IAAI,KAAKP,MAAL,CAAY8B,MAAZ,GAAqB,CAArB,IAA0B,KAAKtB,KAAL,KAAenC,oBAAoB,CAAC+F,MAAlE,EAA0E;MACzE,IAAMa,iBAAiB,GAAGpH,KAAK,CAAC+H,WAAN,CAAkBC,MAAlB,EAA1B;MACA,IAAMC,QAAQ,GAAG,KAAK9F,MAAL,CAAY+F,KAAZ,EAAjB;MACA,KAAK9B,UAAL,CAAgBN,IAAhB,CAAqB;QACpBQ,eAAe,EAAE2B,QADG;QAEpBE,SAAS,EAAE,KAAKC,sBAAL,CAA4BH,QAA5B,EAAsCb,iBAAtC,CAFS;QAGpBiB,MAAM,EAAEjB,iBAAiB,CAACiB;MAHN,CAArB;IAKA;EACD,CAVO;EAYR;;;;;;;;EAMc3F,4CAAd;;;;;;YACa;YAAA;YAAA,EAAM,KAAK4F,eAAL,CAAqB;cACtCzF,GAAG,EAAE,KAAKvB,MAAL,CAAYmC,GADqB;cAEtCX,MAAM,EAAE,KAAKxB,MAAL,CAAY0B;YAFkB,CAArB,CAAN;;;YAANM,GAAG,GAAGrC,SAAN;YAIAsH,KAAK,GAAGC,OAAO,CAAClF,GAAG,IAAIA,GAAG,CAACmF,IAAJ,KAAa,KAAKtH,IAAL,CAAUc,IAA/B,CAAf;;YACN,IAAI,CAACsG,KAAL,EAAY;cACX,MAAM,IAAIlD,KAAJ,CACL,4DADK,CAAN;YAGA;;YACD;YAAA;YAAA,EAAOkD,KAAP;;;;EACA,CAZa;;EAcN7F,oCAAR;IACC,OACC,CAAC,KAAKP,MAAL,CAAY8B,MAAb,IACA,CAAC,KAAKmC,UAAL,CAAgBnC,MADjB,IAEA,KAAK/B,aAAL,KAAuB,KAAKF,UAH7B;EAKA,CANO;;EAQAU,yCAAR;IACC,IAAMT,IAAI,GAAG,KAAKd,IAAL,CAAUc,IAAvB;IACA,IAAMoC,KAAK,GAA6B,EAAxC;;IACA,KAAK,IAAIqE,SAAS,GAAG,CAArB,EAAwBA,SAAS,GAAGzG,IAApC,GAA4C;MAC3C,IAAM0G,OAAO,GAAGC,IAAI,CAACC,GAAL,CAASH,SAAS,GAAG,KAAKtD,QAA1B,EAAoCnD,IAApC,CAAhB;MACAoC,KAAK,CAACyB,IAAN,CAAW;QACVyB,IAAI,EAAE,KAAKpG,IAAL,CAAU2H,KAAV,CAAgBJ,SAAhB,EAA2BC,OAA3B,CADI;QAEVlF,GAAG,EAAE,KAAKnC,MAAL,CAAYmC,GAFP;QAGVT,MAAM,EAAE,KAAK1B,MAAL,CAAY0B,MAHV;QAIVhC,UAAU,EAAEqD,KAAK,CAACJ,MAAN,GAAe,CAJjB;QAKVa,QAAQ,EAAE,KAAKR;MALL,CAAX;MAOAoE,SAAS,IAAI,KAAKtD,QAAlB;IACA;;IACD,OAAOf,KAAP;EACA,CAfO;;EAiBA3B,mDAAR,UAA+BqG,WAA/B,EAAkD;IACjD,KAAK7G,aAAL,IAAsB6G,WAAW,CAACC,MAAZ,CAAmB,UAACC,GAAD,EAAMC,IAAN,EAAU;MAAK,UAAG,GAAGA,IAAI,CAACT,IAAX;IAAe,CAAjD,EAAmD,CAAnD,CAAtB,CADiD,CAEjD;;IACA,IAAMU,kBAAkB,GAAG,IAAIC,GAAJ,CAC1BL,WAAW,CAACM,GAAZ,CAAgB,gBAAI;MAAI,WAAI,CAACrI,UAAL;IAAe,CAAvC,CAD0B,CAA3B;IAGA,KAAKmB,MAAL,GAAc,KAAKA,MAAL,CAAYkE,MAAZ,CACb,gBAAI;MAAI,QAAC8C,kBAAkB,CAACG,GAAnB,CAAuBJ,IAAI,CAAClI,UAA5B,CAAD;IAAwC,CADnC,CAAd;IAGA,KAAK6E,cAAL,GAAsBkD,WAAW,CAACM,GAAZ,CAAgB,gBAAI;MAAI,OAAC;QAC9CrI,UAAU,EAAEkI,IAAI,CAAClI,UAD6B;QAE9C+E,IAAI,EAAEmD,IAAI,CAACnD;MAFmC,CAAD;IAG5C,CAHoB,CAAtB;;IAIA,KAAKC,UAAL,CAAyCvF,UAAU,CAACwF,eAApD,EAAqE;MACpEC,MAAM,EAAE,KAAKhE,aADuD;MAEpEiE,KAAK,EAAE,KAAKnE;IAFwD,CAArE;EAIA,CAjBO;;EAmBMU,iDAAd;;;;;;YACa;YAAA;YAAA,EAAM,KAAKhB,QAAL,CAAcqB,IAAd,CACjB,IAAIjD,4BAAJ,CAAiC,KAAKwB,MAAtC,CADiB,CAAN;;;YAAN+F,GAAG,GAAGpG,SAAN;;YAGN,KAAKsI,MAAL,CAAY;cACXjF,QAAQ,EAAE+C,GAAG,CAACvC,QADH;cAEXN,WAAW,EAAEC,IAAI,CAACC,GAAL,EAFF;cAGX5B,MAAM,EAAE,KAAKxB,MAAL,CAAY0B,MAHT;cAIXH,GAAG,EAAE,KAAKvB,MAAL,CAAYmC,GAJN;cAKX+F,QAAQ,EAAE,KAAKrI,IAAL,YAAqBsI,IAArB,GAA4B,KAAKtI,IAAL,CAAUuC,IAAtC,GAA6C;YAL5C,CAAZ;;YAOA;YAAA;YAAA,EAAO2D,GAAG,CAACvC,QAAX;;;;EACA,CAZa;;EAcApC,kDAAd;;;;;;;YACC,KAAKC,KAAL,GAAanC,oBAAoB,CAACoC,WAAlC;;;;;;YAEK;YAAA;YAAA,EAAM,KAAK8G,SAAL,EAAN;;;iBAAAtG;YAAA;YAAA;YACyB;YAAA;YAAA,EAAM,KAAKuG,sBAAL,EAAN;;;YAAtB1I,KAAsBmC,SAAtB,EAAEiB,KAAK,WAAP,EAASC,QAAQ,cAAjB;YACN,KAAKA,QAAL,GAAgBA,QAAhB;YACA,KAAKnC,MAAL,GAAc,KAAKyH,YAAL,EAAd;;YACA,KAAKC,sBAAL,CAA4BxF,KAA5B;;YACA,KAAKyF,YAAL;;;;;;;iBAEI,CAAC,KAAKxF,UAAN;YAAA;YAAA;YACc;YAAA;YAAA,EAAM,KAAKyF,oBAAL,EAAN;;;YAAXzF,QAAQ,GAAGlB,SAAX;YACN,KAAKkB,QAAL,GAAgBA,QAAhB;YACA,KAAKnC,MAAL,GAAc,KAAKyH,YAAL,EAAd;;YACA,KAAKE,YAAL;;;;;;;;;;;;YAIF,IAAI,CAAC9J,KAAK,CAAC2H,QAAN,CAAeqC,KAAf,CAAL,EAA0B;cACzBzJ,MAAM,CAAC0G,KAAP,CAAa,oCAAb,EAAmD+C,KAAnD;YACA;;;;;;;;;;;;;EAEF,CAtBa;;EAwBPtH,mCAAP;IACC,IAAI,KAAKC,KAAL,KAAenC,oBAAoB,CAACiH,SAAxC,EAAmD;MAClDlH,MAAM,CAAC0J,IAAP,CAAY,sCAAZ;IACA,CAFD,MAEO,IAAI,KAAKtH,KAAL,KAAenC,oBAAoB,CAACwG,SAAxC,EAAmD;MACzDzG,MAAM,CAAC0J,IAAP,CAAY,sCAAZ;IACA,CAFM,MAEA,IAAI,KAAKtH,KAAL,KAAenC,oBAAoB,CAACoC,WAAxC,EAAqD;MAC3DrC,MAAM,CAAC0J,IAAP,CAAY,iCAAZ,EAD2D,CAE3D;MACA;IACA,CAJM,MAIA,IAAI,CAAC,KAAK3F,QAAV,EAAoB;MAC1B,KAAK4F,qBAAL;IACA,CAFM,MAEA;MACN,KAAKJ,YAAL;IACA;EACD,CAdM;;EAgBCpH,yCAAR;IACC,KAAKC,KAAL,GAAanC,oBAAoB,CAACoC,WAAlC;;IACA,KAAK,IAAIuH,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG,KAAKC,SAAzB,EAAoCD,CAAC,EAArC,EAAyC;MACxC,KAAK3D,cAAL;IACA;EACD,CALO;;EAOF9D,oCAAN;;;;;;kBACK,KAAKC,KAAL,KAAenC,oBAAoB,CAACiH,YAApC;YAAA;YAAA;YACHlH,MAAM,CAAC0J,IAAP,CAAY,sCAAZ;YACA;YAAA;YAAA,EAAO,KAAP;;;kBACU,KAAKtH,KAAL,KAAenC,oBAAoB,CAACwG,YAApC;YAAA;YAAA;YACVzG,MAAM,CAAC0J,IAAP,CAAY,sCAAZ;YACA;YAAA;YAAA,EAAO,KAAP;;;YAEA,KAAKnC,KAAL;YACA,KAAK3F,MAAL,GAAc,EAAd;YACA,KAAK0D,cAAL,GAAsB,EAAtB;YACA,KAAK3D,aAAL,GAAqB,CAArB;YACA,KAAKS,KAAL,GAAanC,oBAAoB,CAACiH,SAAlC;;;;;;YAEC;YAAA;YAAA,EAAM,KAAK/F,QAAL,CAAcqB,IAAd,CACL,IAAInD,2BAAJ,CAAgC;cAC/BoD,MAAM,EAAE,KAAK1B,MAAL,CAAY0B,MADW;cAE/BS,GAAG,EAAE,KAAKnC,MAAL,CAAYmC,GAFc;cAG/BqB,QAAQ,EAAE,KAAKR;YAHgB,CAAhC,CADK,CAAN;;;YAAArD;;YAOA;YAAA;YAAA,EAAM,KAAK8F,gBAAL,EAAN;;;YAAA9F;;YACA;YAAA;YAAA,EAAO,IAAP;;;;YAEAV,MAAM,CAAC0G,KAAP,CAAa,8BAAb,EAA6CoD,KAA7C;YACA;YAAA;YAAA,EAAO,KAAP;;;;;;;;;EAGF,CA5BK;EA8BN;;;;;EAGO3H,kCAAP;;;IACC,IAAI,KAAKC,KAAL,KAAenC,oBAAoB,CAACiH,SAAxC,EAAmD;MAClDlH,MAAM,CAAC0J,IAAP,CAAY,sCAAZ;IACA,CAFD,MAEO,IAAI,KAAKtH,KAAL,KAAenC,oBAAoB,CAACwG,SAAxC,EAAmD;MACzDzG,MAAM,CAAC0J,IAAP,CAAY,sCAAZ;IACA,CAFM,MAEA,IAAI,KAAKtH,KAAL,KAAenC,oBAAoB,CAAC+F,MAAxC,EAAgD;MACtDhG,MAAM,CAAC0J,IAAP,CAAY,6BAAZ;IACA;;IACD,KAAKtH,KAAL,GAAanC,oBAAoB,CAAC+F,MAAlC,CARD,CASC;IACA;;IACA,IAAM+D,oBAAoB,GAAG,KAAKlE,UAAL,CAAgBmE,MAAhB,CAC5B,CAD4B,EAE5B,KAAKnE,UAAL,CAAgBnC,MAFY,CAA7B;IAIAqG,oBAAoB,CAACE,OAArB,CAA6B,eAAG;MAC/BC,GAAG,CAACpC,MAAJ,CAAWjI,+BAA+B,CAACyH,qBAA3C;IACA,CAFD,EAfD,CAkBC;;IACA,WAAK1F,MAAL,EAAYuI,OAAZ,CAAmBC,KAAnB,CAAmB1J,EAAnB,EAAmB2J,SACfN,oBAAoB,CAACjB,GAArB,CAAyB,eAAG;MAAI,UAAG,CAAC/C,eAAJ;IAAmB,CAAnD,CADe,CAAnB;EAGA,CAtBM;;EAuBR;AAAC,CAjcD","names":["UploadPartCommand","CompleteMultipartUploadCommand","AbortMultipartUploadCommand","ListPartsCommand","CreateMultipartUploadCommand","ListObjectsV2Command","axios","Logger","byteLength","isFile","AWSS3ProviderUploadErrorStrings","SET_CONTENT_LENGTH_HEADER","UPLOADS_STORAGE_KEY","logger","AWSS3UploadTaskState","TaskEvents","MAX_PARTS","PART_SIZE","DEFAULT_QUEUE_SIZE","comparePartNumber","a","b","PartNumber","_a","s3Client","file","emitter","storage","params","level","prefixPromise","INIT","s3client","middlewareStack","remove","storageSync","Promise","resolve","totalBytes","size","bytesUploaded","queued","fileId","_getFileId","_validateParams","on","ERROR","Object","AWSS3UploadTask","state","IN_PROGRESS","key","bucket","send","Bucket","Prefix","listObjectRes","_c","_b","prefix","obj","Contents","find","Key","name","lastModified","type","join","_listCachedUploadTasks","uploadRequests","keys","length","prototype","hasOwnProperty","call","parts","uploadId","cachedUploadFileData","lastTouched","Date","now","setItem","JSON","stringify","UploadId","listPartsOutput","Parts","event","payload","emit","partSize","Error","tasks","getItem","parse","fileMetadata","eTag","partNumber","chunk","completedParts","push","ETag","_emitEvent","UPLOAD_PROGRESS","loaded","total","inProgress","filter","uploadPartInput","PAUSED","_startNextPart","_isDone","_completeUpload","MultipartUpload","sort","_verifyFileSize","UPLOAD_COMPLETE","_removeFromCache","COMPLETED","error","err_1","input","cancelTokenSource","res","_onPartUploadCompletion","Body","log","CANCELLED","err_2","isCancel","message","UPLOAD_PAUSED_MESSAGE","pause","CancelToken","source","nextPart","shift","s3Request","_makeUploadPartRequest","cancel","_listSingleFile","valid","Boolean","Size","bodyStart","bodyEnd","Math","min","slice","cachedParts","reduce","acc","part","uploadedPartNumSet","Set","map","has","_cache","fileName","File","_isCached","_findCachedUploadParts","_createParts","_initCachedUploadParts","_startUpload","_initMultipartUpload","err_3","warn","_initializeUploadTask","i","queueSize","err_4","removedInProgressReq","splice","forEach","req","unshift","apply","__spread"],"sources":["C:\\Users\\jacob\\OneDrive\\College\\Freshman_2021-2022\\Summer_2022\\COM4570H\\newcrm\\new-crm\\node_modules\\@aws-amplify\\storage\\src\\providers\\AWSS3UploadTask.ts"],"sourcesContent":["import {\n\tUploadPartCommandInput,\n\tCompletedPart,\n\tS3Client,\n\tUploadPartCommand,\n\tCompleteMultipartUploadCommand,\n\tPart,\n\tAbortMultipartUploadCommand,\n\tListPartsCommand,\n\tCreateMultipartUploadCommand,\n\tPutObjectCommandInput,\n\tListObjectsV2Command,\n} from '@aws-sdk/client-s3';\nimport * as events from 'events';\nimport axios, { Canceler, CancelTokenSource } from 'axios';\nimport { HttpHandlerOptions } from '@aws-sdk/types';\nimport { Logger } from '@aws-amplify/core';\nimport { UploadTask } from '../types/Provider';\nimport { byteLength, isFile } from '../common/StorageUtils';\nimport { AWSS3ProviderUploadErrorStrings } from '../common/StorageErrorStrings';\nimport {\n\tSET_CONTENT_LENGTH_HEADER,\n\tUPLOADS_STORAGE_KEY,\n} from '../common/StorageConstants';\nimport { StorageAccessLevel } from '..';\n\nconst logger = new Logger('AWSS3UploadTask');\nexport enum AWSS3UploadTaskState {\n\tINIT,\n\tIN_PROGRESS,\n\tPAUSED,\n\tCANCELLED,\n\tCOMPLETED,\n}\n\nexport enum TaskEvents {\n\tCANCEL = 'cancel',\n\tUPLOAD_COMPLETE = 'uploadComplete',\n\tUPLOAD_PROGRESS = 'uploadPartProgress',\n\tERROR = 'error',\n}\n\nexport interface AWSS3UploadTaskParams {\n\ts3Client: S3Client;\n\tfile: Blob;\n\tstorage: Storage;\n\tlevel: StorageAccessLevel;\n\tparams: PutObjectCommandInput;\n\tprefixPromise: Promise<string>;\n\temitter?: events.EventEmitter;\n}\n\nexport interface InProgressRequest {\n\tuploadPartInput: UploadPartCommandInput;\n\ts3Request: Promise<any>;\n\tcancel: Canceler;\n}\n\nexport interface UploadTaskCompleteEvent {\n\tkey: string;\n}\n\nexport interface UploadTaskProgressEvent {\n\t/**\n\t * bytes that has been sent to S3 so far\n\t */\n\tloaded: number;\n\t/**\n\t * total bytes that needs to be sent to S3\n\t */\n\ttotal: number;\n}\n\nexport interface FileMetadata {\n\tbucket: string;\n\tfileName: string;\n\tkey: string;\n\t// Unix timestamp in ms\n\tlastTouched: number;\n\tuploadId: string;\n}\n\n// maximum number of parts per upload request according the S3 spec,\n// see: https://docs.aws.amazon.com/AmazonS3/latest/userguide/qfacts.html\nconst MAX_PARTS = 10000;\n// 5MB in bytes\nconst PART_SIZE = 5 * 1024 * 1024;\nconst DEFAULT_QUEUE_SIZE = 4;\n\nfunction comparePartNumber(a: CompletedPart, b: CompletedPart) {\n\treturn a.PartNumber - b.PartNumber;\n}\n\nexport class AWSS3UploadTask implements UploadTask {\n\tprivate readonly emitter: events.EventEmitter;\n\tprivate readonly file: Blob;\n\tprivate readonly partSize: number = PART_SIZE;\n\tprivate readonly queueSize = DEFAULT_QUEUE_SIZE;\n\tprivate readonly s3client: S3Client;\n\tprivate readonly storage: Storage;\n\tprivate readonly storageSync: Promise<any>;\n\tprivate readonly fileId: string;\n\tprivate readonly params: PutObjectCommandInput;\n\tprivate readonly prefixPromise: Promise<string>;\n\tprivate inProgress: InProgressRequest[] = [];\n\tprivate completedParts: CompletedPart[] = [];\n\tprivate queued: UploadPartCommandInput[] = [];\n\tprivate bytesUploaded: number = 0;\n\tprivate totalBytes: number = 0;\n\tprivate uploadId: string;\n\n\tpublic state: AWSS3UploadTaskState = AWSS3UploadTaskState.INIT;\n\n\tconstructor({\n\t\ts3Client,\n\t\tfile,\n\t\temitter,\n\t\tstorage,\n\t\tparams,\n\t\tlevel,\n\t\tprefixPromise,\n\t}: AWSS3UploadTaskParams) {\n\t\tthis.prefixPromise = prefixPromise;\n\t\tthis.s3client = s3Client;\n\t\tthis.s3client.middlewareStack.remove(SET_CONTENT_LENGTH_HEADER);\n\t\tthis.storage = storage;\n\t\tthis.storageSync = Promise.resolve();\n\t\tif (typeof this.storage['sync'] === 'function') {\n\t\t\tthis.storageSync = this.storage['sync']();\n\t\t}\n\t\tthis.params = params;\n\t\tthis.file = file;\n\t\tthis.totalBytes = this.file.size;\n\t\tthis.bytesUploaded = 0;\n\t\tthis.emitter = emitter;\n\t\tthis.queued = [];\n\t\tthis.fileId = this._getFileId(level);\n\t\tthis._validateParams();\n\t\t// event emitter will re-throw an error if an event emits an error unless there's a listener, attaching a no-op\n\t\t// function to it unless user adds their own onError callback\n\t\tthis.emitter.on(TaskEvents.ERROR, () => {});\n\t}\n\n\tget percent() {\n\t\treturn (this.bytesUploaded / this.totalBytes) * 100;\n\t}\n\n\tget isInProgress() {\n\t\treturn this.state === AWSS3UploadTaskState.IN_PROGRESS;\n\t}\n\n\tprivate async _listSingleFile({\n\t\tkey,\n\t\tbucket,\n\t}: {\n\t\tkey: string;\n\t\tbucket: string;\n\t}) {\n\t\tconst listObjectRes = await this.s3client.send(\n\t\t\tnew ListObjectsV2Command({\n\t\t\t\tBucket: bucket,\n\t\t\t\tPrefix: key,\n\t\t\t})\n\t\t);\n\t\tconst { Contents = [] } = listObjectRes;\n\t\tconst prefix = await this.prefixPromise;\n\t\tconst obj = Contents.find(o => o.Key === `${prefix}${key}`);\n\t\treturn obj;\n\t}\n\n\tprivate _getFileId(level: StorageAccessLevel): string {\n\t\t// We should check if it's a File first because File is also instance of a Blob\n\t\tif (isFile(this.file)) {\n\t\t\treturn [\n\t\t\t\tthis.file.name,\n\t\t\t\tthis.file.lastModified,\n\t\t\t\tthis.file.size,\n\t\t\t\tthis.file.type,\n\t\t\t\tthis.params.Bucket,\n\t\t\t\tlevel,\n\t\t\t\tthis.params.Key,\n\t\t\t].join('-');\n\t\t} else {\n\t\t\treturn [\n\t\t\t\tthis.file.size,\n\t\t\t\tthis.file.type,\n\t\t\t\tthis.params.Bucket,\n\t\t\t\tlevel,\n\t\t\t\tthis.params.Key,\n\t\t\t].join('-');\n\t\t}\n\t}\n\n\tprivate async _findCachedUploadParts(): Promise<{\n\t\tparts: Part[];\n\t\tuploadId: string;\n\t}> {\n\t\tconst uploadRequests = await this._listCachedUploadTasks();\n\n\t\tif (\n\t\t\tObject.keys(uploadRequests).length === 0 ||\n\t\t\t!Object.prototype.hasOwnProperty.call(uploadRequests, this.fileId)\n\t\t) {\n\t\t\treturn { parts: [], uploadId: null };\n\t\t}\n\n\t\tconst cachedUploadFileData = uploadRequests[this.fileId];\n\t\tcachedUploadFileData.lastTouched = Date.now();\n\t\tthis.storage.setItem(UPLOADS_STORAGE_KEY, JSON.stringify(uploadRequests));\n\n\t\tconst listPartsOutput = await this.s3client.send(\n\t\t\tnew ListPartsCommand({\n\t\t\t\tBucket: this.params.Bucket,\n\t\t\t\tKey: this.params.Key,\n\t\t\t\tUploadId: cachedUploadFileData.uploadId,\n\t\t\t})\n\t\t);\n\n\t\treturn {\n\t\t\tparts: listPartsOutput.Parts || [],\n\t\t\tuploadId: cachedUploadFileData.uploadId,\n\t\t};\n\t}\n\n\tprivate _emitEvent<T = any>(event: string, payload: T) {\n\t\tthis.emitter.emit(event, payload);\n\t}\n\n\tprivate _validateParams() {\n\t\tif (this.file.size / this.partSize > MAX_PARTS) {\n\t\t\tthrow new Error(\n\t\t\t\t`Too many parts. Number of parts is ${this.file.size /\n\t\t\t\t\tthis.partSize}, maximum is ${MAX_PARTS}.`\n\t\t\t);\n\t\t}\n\t}\n\n\tprivate async _listCachedUploadTasks(): Promise<\n\t\tRecord<string, FileMetadata>\n\t> {\n\t\tawait this.storageSync;\n\t\tconst tasks = this.storage.getItem(UPLOADS_STORAGE_KEY) || '{}';\n\t\treturn JSON.parse(tasks);\n\t}\n\n\tprivate async _cache(fileMetadata: FileMetadata): Promise<void> {\n\t\tconst uploadRequests = await this._listCachedUploadTasks();\n\t\tuploadRequests[this.fileId] = fileMetadata;\n\t\tthis.storage.setItem(UPLOADS_STORAGE_KEY, JSON.stringify(uploadRequests));\n\t}\n\n\tprivate async _isCached(): Promise<boolean> {\n\t\treturn Object.prototype.hasOwnProperty.call(\n\t\t\tawait this._listCachedUploadTasks(),\n\t\t\tthis.fileId\n\t\t);\n\t}\n\n\tprivate async _removeFromCache(): Promise<void> {\n\t\tconst uploadRequests = await this._listCachedUploadTasks();\n\t\tdelete uploadRequests[this.fileId];\n\t\tthis.storage.setItem(UPLOADS_STORAGE_KEY, JSON.stringify(uploadRequests));\n\t}\n\n\tprivate async _onPartUploadCompletion({\n\t\teTag,\n\t\tpartNumber,\n\t\tchunk,\n\t}: {\n\t\teTag: string;\n\t\tpartNumber: number;\n\t\tchunk: UploadPartCommandInput['Body'];\n\t}) {\n\t\tthis.completedParts.push({\n\t\t\tETag: eTag,\n\t\t\tPartNumber: partNumber,\n\t\t});\n\t\tthis.bytesUploaded += byteLength(chunk);\n\t\tthis._emitEvent<UploadTaskProgressEvent>(TaskEvents.UPLOAD_PROGRESS, {\n\t\t\tloaded: this.bytesUploaded,\n\t\t\ttotal: this.totalBytes,\n\t\t});\n\t\t// Remove the completed item from the inProgress array\n\t\tthis.inProgress = this.inProgress.filter(\n\t\t\tjob => job.uploadPartInput.PartNumber !== partNumber\n\t\t);\n\t\tif (this.queued.length && this.state !== AWSS3UploadTaskState.PAUSED)\n\t\t\tthis._startNextPart();\n\t\tif (this._isDone()) this._completeUpload();\n\t}\n\n\tprivate async _completeUpload() {\n\t\ttry {\n\t\t\tawait this.s3client.send(\n\t\t\t\tnew CompleteMultipartUploadCommand({\n\t\t\t\t\tBucket: this.params.Bucket,\n\t\t\t\t\tKey: this.params.Key,\n\t\t\t\t\tUploadId: this.uploadId,\n\t\t\t\t\tMultipartUpload: {\n\t\t\t\t\t\t// Parts are not always completed in order, we need to manually sort them\n\t\t\t\t\t\tParts: this.completedParts.sort(comparePartNumber),\n\t\t\t\t\t},\n\t\t\t\t})\n\t\t\t);\n\t\t\tthis._verifyFileSize();\n\t\t\tthis._emitEvent<UploadTaskCompleteEvent>(TaskEvents.UPLOAD_COMPLETE, {\n\t\t\t\tkey: `${this.params.Bucket}/${this.params.Key}`,\n\t\t\t});\n\t\t\tthis._removeFromCache();\n\t\t\tthis.state = AWSS3UploadTaskState.COMPLETED;\n\t\t} catch (err) {\n\t\t\tlogger.error('error completing upload', err);\n\t\t\tthis._emitEvent(TaskEvents.ERROR, err);\n\t\t}\n\t}\n\n\tprivate async _makeUploadPartRequest(\n\t\tinput: UploadPartCommandInput,\n\t\tcancelTokenSource: CancelTokenSource\n\t) {\n\t\ttry {\n\t\t\tconst res = await this.s3client.send(new UploadPartCommand(input), {\n\t\t\t\tcancelTokenSource,\n\t\t\t} as HttpHandlerOptions);\n\t\t\tawait this._onPartUploadCompletion({\n\t\t\t\teTag: res.ETag,\n\t\t\t\tpartNumber: input.PartNumber,\n\t\t\t\tchunk: input.Body,\n\t\t\t});\n\t\t} catch (err) {\n\t\t\tif (this.state === AWSS3UploadTaskState.PAUSED) {\n\t\t\t\tlogger.log('upload paused');\n\t\t\t} else if (this.state === AWSS3UploadTaskState.CANCELLED) {\n\t\t\t\tlogger.log('upload aborted');\n\t\t\t} else {\n\t\t\t\tlogger.error('error starting next part of upload: ', err);\n\t\t\t}\n\t\t\t// axios' cancel will also throw an error, however we don't need to emit an event in that case as it's an\n\t\t\t// expected behavior\n\t\t\tif (\n\t\t\t\t!axios.isCancel(err) &&\n\t\t\t\terr.message !== AWSS3ProviderUploadErrorStrings.UPLOAD_PAUSED_MESSAGE\n\t\t\t) {\n\t\t\t\tthis._emitEvent(TaskEvents.ERROR, err);\n\t\t\t\tthis.pause();\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate _startNextPart() {\n\t\tif (this.queued.length > 0 && this.state !== AWSS3UploadTaskState.PAUSED) {\n\t\t\tconst cancelTokenSource = axios.CancelToken.source();\n\t\t\tconst nextPart = this.queued.shift();\n\t\t\tthis.inProgress.push({\n\t\t\t\tuploadPartInput: nextPart,\n\t\t\t\ts3Request: this._makeUploadPartRequest(nextPart, cancelTokenSource),\n\t\t\t\tcancel: cancelTokenSource.cancel,\n\t\t\t});\n\t\t}\n\t}\n\n\t/**\n\t * Verify on S3 side that the file size matches the one on the client side.\n\t *\n\t * @async\n\t * @throws throws an error if the file size does not match between local copy of the file and the file on s3.\n\t */\n\tprivate async _verifyFileSize() {\n\t\tconst obj = await this._listSingleFile({\n\t\t\tkey: this.params.Key,\n\t\t\tbucket: this.params.Bucket,\n\t\t});\n\t\tconst valid = Boolean(obj && obj.Size === this.file.size);\n\t\tif (!valid) {\n\t\t\tthrow new Error(\n\t\t\t\t'File size does not match between local file and file on s3'\n\t\t\t);\n\t\t}\n\t\treturn valid;\n\t}\n\n\tprivate _isDone() {\n\t\treturn (\n\t\t\t!this.queued.length &&\n\t\t\t!this.inProgress.length &&\n\t\t\tthis.bytesUploaded === this.totalBytes\n\t\t);\n\t}\n\n\tprivate _createParts() {\n\t\tconst size = this.file.size;\n\t\tconst parts: UploadPartCommandInput[] = [];\n\t\tfor (let bodyStart = 0; bodyStart < size; ) {\n\t\t\tconst bodyEnd = Math.min(bodyStart + this.partSize, size);\n\t\t\tparts.push({\n\t\t\t\tBody: this.file.slice(bodyStart, bodyEnd),\n\t\t\t\tKey: this.params.Key,\n\t\t\t\tBucket: this.params.Bucket,\n\t\t\t\tPartNumber: parts.length + 1,\n\t\t\t\tUploadId: this.uploadId,\n\t\t\t});\n\t\t\tbodyStart += this.partSize;\n\t\t}\n\t\treturn parts;\n\t}\n\n\tprivate _initCachedUploadParts(cachedParts: Part[]) {\n\t\tthis.bytesUploaded += cachedParts.reduce((acc, part) => acc + part.Size, 0);\n\t\t// Find the set of part numbers that have already been uploaded\n\t\tconst uploadedPartNumSet = new Set(\n\t\t\tcachedParts.map(part => part.PartNumber)\n\t\t);\n\t\tthis.queued = this.queued.filter(\n\t\t\tpart => !uploadedPartNumSet.has(part.PartNumber)\n\t\t);\n\t\tthis.completedParts = cachedParts.map(part => ({\n\t\t\tPartNumber: part.PartNumber,\n\t\t\tETag: part.ETag,\n\t\t}));\n\t\tthis._emitEvent<UploadTaskProgressEvent>(TaskEvents.UPLOAD_PROGRESS, {\n\t\t\tloaded: this.bytesUploaded,\n\t\t\ttotal: this.totalBytes,\n\t\t});\n\t}\n\n\tprivate async _initMultipartUpload() {\n\t\tconst res = await this.s3client.send(\n\t\t\tnew CreateMultipartUploadCommand(this.params)\n\t\t);\n\t\tthis._cache({\n\t\t\tuploadId: res.UploadId,\n\t\t\tlastTouched: Date.now(),\n\t\t\tbucket: this.params.Bucket,\n\t\t\tkey: this.params.Key,\n\t\t\tfileName: this.file instanceof File ? this.file.name : '',\n\t\t});\n\t\treturn res.UploadId;\n\t}\n\n\tprivate async _initializeUploadTask() {\n\t\tthis.state = AWSS3UploadTaskState.IN_PROGRESS;\n\t\ttry {\n\t\t\tif (await this._isCached()) {\n\t\t\t\tconst { parts, uploadId } = await this._findCachedUploadParts();\n\t\t\t\tthis.uploadId = uploadId;\n\t\t\t\tthis.queued = this._createParts();\n\t\t\t\tthis._initCachedUploadParts(parts);\n\t\t\t\tthis._startUpload();\n\t\t\t} else {\n\t\t\t\tif (!this.uploadId) {\n\t\t\t\t\tconst uploadId = await this._initMultipartUpload();\n\t\t\t\t\tthis.uploadId = uploadId;\n\t\t\t\t\tthis.queued = this._createParts();\n\t\t\t\t\tthis._startUpload();\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (err) {\n\t\t\tif (!axios.isCancel(err)) {\n\t\t\t\tlogger.error('Error initializing the upload task', err);\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic resume(): void {\n\t\tif (this.state === AWSS3UploadTaskState.CANCELLED) {\n\t\t\tlogger.warn('This task has already been cancelled');\n\t\t} else if (this.state === AWSS3UploadTaskState.COMPLETED) {\n\t\t\tlogger.warn('This task has already been completed');\n\t\t} else if (this.state === AWSS3UploadTaskState.IN_PROGRESS) {\n\t\t\tlogger.warn('Upload task already in progress');\n\t\t\t// first time running resume, find any cached parts on s3 or start a new multipart upload request before\n\t\t\t// starting the upload\n\t\t} else if (!this.uploadId) {\n\t\t\tthis._initializeUploadTask();\n\t\t} else {\n\t\t\tthis._startUpload();\n\t\t}\n\t}\n\n\tprivate _startUpload() {\n\t\tthis.state = AWSS3UploadTaskState.IN_PROGRESS;\n\t\tfor (let i = 0; i < this.queueSize; i++) {\n\t\t\tthis._startNextPart();\n\t\t}\n\t}\n\n\tasync _cancel(): Promise<boolean> {\n\t\tif (this.state === AWSS3UploadTaskState.CANCELLED) {\n\t\t\tlogger.warn('This task has already been cancelled');\n\t\t\treturn false;\n\t\t} else if (this.state === AWSS3UploadTaskState.COMPLETED) {\n\t\t\tlogger.warn('This task has already been completed');\n\t\t\treturn false;\n\t\t} else {\n\t\t\tthis.pause();\n\t\t\tthis.queued = [];\n\t\t\tthis.completedParts = [];\n\t\t\tthis.bytesUploaded = 0;\n\t\t\tthis.state = AWSS3UploadTaskState.CANCELLED;\n\t\t\ttry {\n\t\t\t\tawait this.s3client.send(\n\t\t\t\t\tnew AbortMultipartUploadCommand({\n\t\t\t\t\t\tBucket: this.params.Bucket,\n\t\t\t\t\t\tKey: this.params.Key,\n\t\t\t\t\t\tUploadId: this.uploadId,\n\t\t\t\t\t})\n\t\t\t\t);\n\t\t\t\tawait this._removeFromCache();\n\t\t\t\treturn true;\n\t\t\t} catch (err) {\n\t\t\t\tlogger.error('Error cancelling upload task', err);\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * pause this particular upload task\n\t **/\n\tpublic pause(): void {\n\t\tif (this.state === AWSS3UploadTaskState.CANCELLED) {\n\t\t\tlogger.warn('This task has already been cancelled');\n\t\t} else if (this.state === AWSS3UploadTaskState.COMPLETED) {\n\t\t\tlogger.warn('This task has already been completed');\n\t\t} else if (this.state === AWSS3UploadTaskState.PAUSED) {\n\t\t\tlogger.warn('This task is already paused');\n\t\t}\n\t\tthis.state = AWSS3UploadTaskState.PAUSED;\n\t\t// Use axios cancel token to abort the part request immediately\n\t\t// Add the inProgress parts back to pending\n\t\tconst removedInProgressReq = this.inProgress.splice(\n\t\t\t0,\n\t\t\tthis.inProgress.length\n\t\t);\n\t\tremovedInProgressReq.forEach(req => {\n\t\t\treq.cancel(AWSS3ProviderUploadErrorStrings.UPLOAD_PAUSED_MESSAGE);\n\t\t});\n\t\t// Put all removed in progress parts back into the queue\n\t\tthis.queued.unshift(\n\t\t\t...removedInProgressReq.map(req => req.uploadPartInput)\n\t\t);\n\t}\n}\n"]},"metadata":{},"sourceType":"module"}