{"ast":null,"code":"var __values = this && this.__values || function (o) {\n  var s = typeof Symbol === \"function\" && Symbol.iterator,\n      m = s && o[s],\n      i = 0;\n  if (m) return m.call(o);\n  if (o && typeof o.length === \"number\") return {\n    next: function () {\n      if (o && i >= o.length) o = void 0;\n      return {\n        value: o && o[i++],\n        done: !o\n      };\n    }\n  };\n  throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n};\n\nimport { makeCamelCaseArray, makeCamelCase } from './Utils';\n\nfunction getBoundingBox(geometry) {\n  if (!geometry) return undefined;\n  return makeCamelCase(geometry.BoundingBox);\n}\n\nfunction getPolygon(geometry) {\n  if (!geometry) return undefined;\n  return makeCamelCaseArray(Array.from(geometry.Polygon));\n}\n/**\n * Organizes blocks from Rekognition API to each of the categories and and structures\n * their data accordingly.\n * @param {BlockList} source - Array containing blocks returned from Textract API.\n * @return {IdentifyTextOutput} -  Object that categorizes each block and its information.\n */\n\n\nexport function categorizeRekognitionBlocks(blocks) {\n  // Skeleton IdentifyText API response. We will populate it as we iterate through blocks.\n  var response = {\n    text: {\n      fullText: '',\n      words: [],\n      lines: [],\n      linesDetailed: []\n    }\n  }; // We categorize each block by running a forEach loop through them.\n\n  blocks.forEach(function (block) {\n    switch (block.Type) {\n      case 'LINE':\n        response.text.lines.push(block.DetectedText);\n        response.text.linesDetailed.push({\n          text: block.DetectedText,\n          polygon: getPolygon(block.Geometry),\n          boundingBox: getBoundingBox(block.Geometry),\n          page: null\n        });\n        break;\n\n      case 'WORD':\n        response.text.fullText += block.DetectedText + ' ';\n        response.text.words.push({\n          text: block.DetectedText,\n          polygon: getPolygon(block.Geometry),\n          boundingBox: getBoundingBox(block.Geometry)\n        });\n        break;\n    }\n  }); // remove trailing space of fullText\n\n  response.text.fullText = response.text.fullText.substr(0, response.text.fullText.length - 1);\n  return response;\n}\n/**\n * Organizes blocks from Textract API to each of the categories and and structures\n * their data accordingly.\n * @param {BlockList} source - Array containing blocks returned from Textract API.\n * @return {IdentifyTextOutput} -  Object that categorizes each block and its information.\n */\n\nexport function categorizeTextractBlocks(blocks) {\n  // Skeleton IdentifyText API response. We will populate it as we iterate through blocks.\n  var response = {\n    text: {\n      fullText: '',\n      words: [],\n      lines: [],\n      linesDetailed: []\n    }\n  }; // if blocks is an empty array, ie. textract did not detect anything, return empty response.\n\n  if (blocks.length === 0) return response;\n  /**\n   * We categorize each of the blocks by running a forEach loop through them.\n   *\n   * For complex structures such as Tables and KeyValue, we need to trasverse through their children. To do so,\n   * we will post-process them after the for each loop. We do this by storing table and keyvalues in arrays and\n   * mapping other blocks in `blockMap` (id to block) so we can reference them easily later.\n   *\n   * Note that we do not map `WORD` and `TABLE` in `blockMap` because they will not be referenced by any other\n   * block except the Page block.\n   */\n\n  var tableBlocks = Array();\n  var keyValueBlocks = Array();\n  var blockMap = {};\n  blocks.forEach(function (block) {\n    switch (block.BlockType) {\n      case 'LINE':\n        response.text.lines.push(block.Text);\n        response.text.linesDetailed.push({\n          text: block.Text,\n          polygon: getPolygon(block.Geometry),\n          boundingBox: getBoundingBox(block.Geometry),\n          page: block.Page\n        });\n        break;\n\n      case 'WORD':\n        response.text.fullText += block.Text + ' ';\n        response.text.words.push({\n          text: block.Text,\n          polygon: getPolygon(block.Geometry),\n          boundingBox: getBoundingBox(block.Geometry)\n        });\n        blockMap[block.Id] = block;\n        break;\n\n      case 'SELECTION_ELEMENT':\n        var selectionStatus = block.SelectionStatus === 'SELECTED' ? true : false;\n        if (!response.text.selections) response.text.selections = [];\n        response.text.selections.push({\n          selected: selectionStatus,\n          polygon: getPolygon(block.Geometry),\n          boundingBox: getBoundingBox(block.Geometry)\n        });\n        blockMap[block.Id] = block;\n        break;\n\n      case 'TABLE':\n        tableBlocks.push(block);\n        break;\n\n      case 'KEY_VALUE_SET':\n        keyValueBlocks.push(block);\n        blockMap[block.Id] = block;\n        break;\n\n      default:\n        blockMap[block.Id] = block;\n    }\n  }); // remove trailing space in fullText\n\n  response.text.fullText = response.text.fullText.substr(0, response.text.fullText.length - 1); // Post-process complex structures if they exist.\n\n  if (tableBlocks.length !== 0) {\n    var tableResponse_1 = Array();\n    tableBlocks.forEach(function (table) {\n      tableResponse_1.push(constructTable(table, blockMap));\n    });\n    response.text.tables = tableResponse_1;\n  }\n\n  if (keyValueBlocks.length !== 0) {\n    var keyValueResponse_1 = Array();\n    keyValueBlocks.forEach(function (keyValue) {\n      // We need the KeyValue blocks of EntityType = `KEY`, which has both key and value references.\n      var entityTypes = Array.from(keyValue.EntityTypes);\n\n      if (entityTypes.indexOf('KEY') !== -1) {\n        keyValueResponse_1.push(constructKeyValue(keyValue, blockMap));\n      }\n    });\n    response.text.keyValues = keyValueResponse_1;\n  }\n\n  return response;\n}\n/**\n * Constructs a table object using data from its children cells.\n * @param {Block} table - Table block that has references (`Relationships`) to its cells\n * @param {[id: string]: Block} blockMap - Maps block Ids to blocks.\n */\n\nexport function constructTable(table, blockMap) {\n  var e_1, _a, e_2, _b;\n\n  var tableMatrix;\n  tableMatrix = [];\n\n  try {\n    // visit each of the cell associated with the table's relationship.\n    for (var _c = __values(table.Relationships), _d = _c.next(); !_d.done; _d = _c.next()) {\n      var tableRelation = _d.value;\n\n      try {\n        for (var _e = (e_2 = void 0, __values(tableRelation.Ids)), _f = _e.next(); !_f.done; _f = _e.next()) {\n          var cellId = _f.value;\n          var cellBlock = blockMap[cellId];\n          var row = cellBlock.RowIndex - 1; // textract starts indexing at 1, so subtract it by 1.\n\n          var col = cellBlock.ColumnIndex - 1; // textract starts indexing at 1, so subtract it by 1.\n          // extract data contained inside the cell.\n\n          var content = extractContentsFromBlock(cellBlock, blockMap);\n          var cell = {\n            text: content.text,\n            boundingBox: getBoundingBox(cellBlock.Geometry),\n            polygon: getPolygon(cellBlock.Geometry),\n            selected: content.selected,\n            rowSpan: cellBlock.RowSpan,\n            columnSpan: cellBlock.ColumnSpan\n          };\n          if (!tableMatrix[row]) tableMatrix[row] = [];\n          tableMatrix[row][col] = cell;\n        }\n      } catch (e_2_1) {\n        e_2 = {\n          error: e_2_1\n        };\n      } finally {\n        try {\n          if (_f && !_f.done && (_b = _e.return)) _b.call(_e);\n        } finally {\n          if (e_2) throw e_2.error;\n        }\n      }\n    }\n  } catch (e_1_1) {\n    e_1 = {\n      error: e_1_1\n    };\n  } finally {\n    try {\n      if (_d && !_d.done && (_a = _c.return)) _a.call(_c);\n    } finally {\n      if (e_1) throw e_1.error;\n    }\n  }\n\n  var rowSize = tableMatrix.length;\n  var columnSize = tableMatrix[0].length; // Note that we leave spanned cells undefined for distinction\n\n  return {\n    size: {\n      rows: rowSize,\n      columns: columnSize\n    },\n    table: tableMatrix,\n    boundingBox: getBoundingBox(table.Geometry),\n    polygon: getPolygon(table.Geometry)\n  };\n}\n/**\n * Constructs a key value object from its children key and value blocks.\n * @param {Block} KeyValue - KeyValue block that has references (`Relationships`) to its children.\n * @param {[id: string]: Block} blockMap - Maps block Ids to blocks.\n */\n\nexport function constructKeyValue(keyBlock, blockMap) {\n  var e_3, _a, e_4, _b;\n\n  var keyText = '';\n  var valueText = '';\n  var valueSelected;\n\n  try {\n    for (var _c = __values(keyBlock.Relationships), _d = _c.next(); !_d.done; _d = _c.next()) {\n      var keyValueRelation = _d.value;\n\n      if (keyValueRelation.Type === 'CHILD') {\n        // relation refers to key\n        var contents = extractContentsFromBlock(keyBlock, blockMap);\n        keyText = contents.text;\n      } else if (keyValueRelation.Type === 'VALUE') {\n        try {\n          // relation refers to value\n          for (var _e = (e_4 = void 0, __values(keyValueRelation.Ids)), _f = _e.next(); !_f.done; _f = _e.next()) {\n            var valueId = _f.value;\n            var valueBlock = blockMap[valueId];\n            var contents = extractContentsFromBlock(valueBlock, blockMap);\n            valueText = contents.text;\n            if (contents.selected != null) valueSelected = contents.selected;\n          }\n        } catch (e_4_1) {\n          e_4 = {\n            error: e_4_1\n          };\n        } finally {\n          try {\n            if (_f && !_f.done && (_b = _e.return)) _b.call(_e);\n          } finally {\n            if (e_4) throw e_4.error;\n          }\n        }\n      }\n    }\n  } catch (e_3_1) {\n    e_3 = {\n      error: e_3_1\n    };\n  } finally {\n    try {\n      if (_d && !_d.done && (_a = _c.return)) _a.call(_c);\n    } finally {\n      if (e_3) throw e_3.error;\n    }\n  }\n\n  return {\n    key: keyText,\n    value: {\n      text: valueText,\n      selected: valueSelected\n    },\n    polygon: getPolygon(keyBlock.Geometry),\n    boundingBox: getBoundingBox(keyBlock.Geometry)\n  };\n}\n/**\n * Extracts text and selection from input block's children.\n * @param {Block}} block - Block that we want to extract contents from.\n * @param {[id: string]: Block} blockMap - Maps block Ids to blocks.\n */\n\nexport function extractContentsFromBlock(block, blockMap) {\n  var e_5, _a, e_6, _b;\n\n  var words = '';\n  var isSelected;\n\n  if (!block.Relationships) {\n    // some block might have no content\n    return {\n      text: '',\n      selected: undefined\n    };\n  }\n\n  try {\n    for (var _c = __values(block.Relationships), _d = _c.next(); !_d.done; _d = _c.next()) {\n      var relation = _d.value;\n\n      try {\n        for (var _e = (e_6 = void 0, __values(relation.Ids)), _f = _e.next(); !_f.done; _f = _e.next()) {\n          var contentId = _f.value;\n          var contentBlock = blockMap[contentId];\n\n          if (contentBlock.BlockType === 'WORD') {\n            words += contentBlock.Text + ' ';\n          } else if (contentBlock.BlockType === 'SELECTION_ELEMENT') {\n            isSelected = contentBlock.SelectionStatus === 'SELECTED' ? true : false;\n          }\n        }\n      } catch (e_6_1) {\n        e_6 = {\n          error: e_6_1\n        };\n      } finally {\n        try {\n          if (_f && !_f.done && (_b = _e.return)) _b.call(_e);\n        } finally {\n          if (e_6) throw e_6.error;\n        }\n      }\n    }\n  } catch (e_5_1) {\n    e_5 = {\n      error: e_5_1\n    };\n  } finally {\n    try {\n      if (_d && !_d.done && (_a = _c.return)) _a.call(_c);\n    } finally {\n      if (e_5) throw e_5.error;\n    }\n  }\n\n  words = words.substr(0, words.length - 1); // remove trailing space.\n\n  return {\n    text: words,\n    selected: isSelected\n  };\n}","map":{"version":3,"mappings":"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","names":["makeCamelCaseArray","makeCamelCase","getBoundingBox","geometry","undefined","BoundingBox","getPolygon","Array","from","Polygon","categorizeRekognitionBlocks","blocks","response","text","fullText","words","lines","linesDetailed","forEach","block","Type","push","DetectedText","polygon","Geometry","boundingBox","page","substr","length","categorizeTextractBlocks","tableBlocks","keyValueBlocks","blockMap","BlockType","Text","Page","Id","selectionStatus","SelectionStatus","selections","selected","tableResponse_1","constructTable","table","tables","keyValueResponse_1","entityTypes","keyValue","EntityTypes","indexOf","constructKeyValue","keyValues","tableMatrix","Relationships","_d","tableRelation","Ids","_f","cellId","cellBlock","row","RowIndex","col","ColumnIndex","content","extractContentsFromBlock","cell","rowSpan","RowSpan","columnSpan","ColumnSpan","rowSize","columnSize","size","rows","columns","keyBlock","keyText","valueText","valueSelected","keyValueRelation","contents","valueId","valueBlock","key","value","isSelected","relation","contentId","contentBlock"],"sources":["C:\\Users\\jacob\\OneDrive\\College\\github\\resumeprojectsrepo\\resumeprojects\\EliteManaging\\node_modules\\@aws-amplify\\predictions\\src\\Providers\\IdentifyTextUtils.ts"],"sourcesContent":["import {\n\tIdentifyTextOutput,\n\tTable,\n\tKeyValue,\n\tTableCell,\n\tContent,\n\tBoundingBox,\n\tPolygon,\n\tGeometry,\n} from '../types';\nimport { Block, BlockList, TextDetectionList } from '../types/AWSTypes';\nimport { makeCamelCaseArray, makeCamelCase } from './Utils';\n\nfunction getBoundingBox(geometry: Geometry): BoundingBox {\n\tif (!geometry) return undefined;\n\treturn makeCamelCase(geometry.BoundingBox);\n}\n\nfunction getPolygon(geometry: Geometry): Polygon {\n\tif (!geometry) return undefined;\n\treturn makeCamelCaseArray(Array.from(geometry.Polygon));\n}\n\n/**\n * Organizes blocks from Rekognition API to each of the categories and and structures\n * their data accordingly.\n * @param {BlockList} source - Array containing blocks returned from Textract API.\n * @return {IdentifyTextOutput} -  Object that categorizes each block and its information.\n */\nexport function categorizeRekognitionBlocks(\n\tblocks: TextDetectionList\n): IdentifyTextOutput {\n\t// Skeleton IdentifyText API response. We will populate it as we iterate through blocks.\n\tconst response: IdentifyTextOutput = {\n\t\ttext: {\n\t\t\tfullText: '',\n\t\t\twords: [],\n\t\t\tlines: [],\n\t\t\tlinesDetailed: [],\n\t\t},\n\t};\n\t// We categorize each block by running a forEach loop through them.\n\tblocks.forEach(block => {\n\t\tswitch (block.Type) {\n\t\t\tcase 'LINE':\n\t\t\t\tresponse.text.lines.push(block.DetectedText);\n\t\t\t\tresponse.text.linesDetailed.push({\n\t\t\t\t\ttext: block.DetectedText,\n\t\t\t\t\tpolygon: getPolygon(block.Geometry),\n\t\t\t\t\tboundingBox: getBoundingBox(block.Geometry),\n\t\t\t\t\tpage: null, // rekognition doesn't have this info\n\t\t\t\t});\n\t\t\t\tbreak;\n\t\t\tcase 'WORD':\n\t\t\t\tresponse.text.fullText += block.DetectedText + ' ';\n\t\t\t\tresponse.text.words.push({\n\t\t\t\t\ttext: block.DetectedText,\n\t\t\t\t\tpolygon: getPolygon(block.Geometry),\n\t\t\t\t\tboundingBox: getBoundingBox(block.Geometry),\n\t\t\t\t});\n\t\t\t\tbreak;\n\t\t}\n\t});\n\t// remove trailing space of fullText\n\tresponse.text.fullText = response.text.fullText.substr(\n\t\t0,\n\t\tresponse.text.fullText.length - 1\n\t);\n\treturn response;\n}\n\n/**\n * Organizes blocks from Textract API to each of the categories and and structures\n * their data accordingly.\n * @param {BlockList} source - Array containing blocks returned from Textract API.\n * @return {IdentifyTextOutput} -  Object that categorizes each block and its information.\n */\nexport function categorizeTextractBlocks(\n\tblocks: BlockList\n): IdentifyTextOutput {\n\t// Skeleton IdentifyText API response. We will populate it as we iterate through blocks.\n\tconst response: IdentifyTextOutput = {\n\t\ttext: {\n\t\t\tfullText: '',\n\t\t\twords: [],\n\t\t\tlines: [],\n\t\t\tlinesDetailed: [],\n\t\t},\n\t};\n\t// if blocks is an empty array, ie. textract did not detect anything, return empty response.\n\tif (blocks.length === 0) return response;\n\t/**\n\t * We categorize each of the blocks by running a forEach loop through them.\n\t *\n\t * For complex structures such as Tables and KeyValue, we need to trasverse through their children. To do so,\n\t * we will post-process them after the for each loop. We do this by storing table and keyvalues in arrays and\n\t * mapping other blocks in `blockMap` (id to block) so we can reference them easily later.\n\t *\n\t * Note that we do not map `WORD` and `TABLE` in `blockMap` because they will not be referenced by any other\n\t * block except the Page block.\n\t */\n\tconst tableBlocks: BlockList = Array();\n\tconst keyValueBlocks: BlockList = Array();\n\tconst blockMap: { [id: string]: Block } = {};\n\n\tblocks.forEach(block => {\n\t\tswitch (block.BlockType) {\n\t\t\tcase 'LINE':\n\t\t\t\tresponse.text.lines.push(block.Text);\n\t\t\t\tresponse.text.linesDetailed.push({\n\t\t\t\t\ttext: block.Text,\n\t\t\t\t\tpolygon: getPolygon(block.Geometry),\n\t\t\t\t\tboundingBox: getBoundingBox(block.Geometry),\n\t\t\t\t\tpage: block.Page,\n\t\t\t\t});\n\t\t\t\tbreak;\n\t\t\tcase 'WORD':\n\t\t\t\tresponse.text.fullText += block.Text + ' ';\n\t\t\t\tresponse.text.words.push({\n\t\t\t\t\ttext: block.Text,\n\t\t\t\t\tpolygon: getPolygon(block.Geometry),\n\t\t\t\t\tboundingBox: getBoundingBox(block.Geometry),\n\t\t\t\t});\n\t\t\t\tblockMap[block.Id] = block;\n\t\t\t\tbreak;\n\t\t\tcase 'SELECTION_ELEMENT':\n\t\t\t\tconst selectionStatus =\n\t\t\t\t\tblock.SelectionStatus === 'SELECTED' ? true : false;\n\t\t\t\tif (!response.text.selections) response.text.selections = [];\n\t\t\t\tresponse.text.selections.push({\n\t\t\t\t\tselected: selectionStatus,\n\t\t\t\t\tpolygon: getPolygon(block.Geometry),\n\t\t\t\t\tboundingBox: getBoundingBox(block.Geometry),\n\t\t\t\t});\n\t\t\t\tblockMap[block.Id] = block;\n\t\t\t\tbreak;\n\t\t\tcase 'TABLE':\n\t\t\t\ttableBlocks.push(block);\n\t\t\t\tbreak;\n\t\t\tcase 'KEY_VALUE_SET':\n\t\t\t\tkeyValueBlocks.push(block);\n\t\t\t\tblockMap[block.Id] = block;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tblockMap[block.Id] = block;\n\t\t}\n\t});\n\t// remove trailing space in fullText\n\tresponse.text.fullText = response.text.fullText.substr(\n\t\t0,\n\t\tresponse.text.fullText.length - 1\n\t);\n\n\t// Post-process complex structures if they exist.\n\tif (tableBlocks.length !== 0) {\n\t\tconst tableResponse: Table[] = Array();\n\t\ttableBlocks.forEach(table => {\n\t\t\ttableResponse.push(constructTable(table, blockMap));\n\t\t});\n\t\tresponse.text.tables = tableResponse;\n\t}\n\tif (keyValueBlocks.length !== 0) {\n\t\tconst keyValueResponse: KeyValue[] = Array();\n\t\tkeyValueBlocks.forEach(keyValue => {\n\t\t\t// We need the KeyValue blocks of EntityType = `KEY`, which has both key and value references.\n\t\t\tconst entityTypes = Array.from(keyValue.EntityTypes);\n\t\t\tif (entityTypes.indexOf('KEY') !== -1) {\n\t\t\t\tkeyValueResponse.push(constructKeyValue(keyValue, blockMap));\n\t\t\t}\n\t\t});\n\t\tresponse.text.keyValues = keyValueResponse;\n\t}\n\treturn response;\n}\n\n/**\n * Constructs a table object using data from its children cells.\n * @param {Block} table - Table block that has references (`Relationships`) to its cells\n * @param {[id: string]: Block} blockMap - Maps block Ids to blocks.\n */\nexport function constructTable(\n\ttable: Block,\n\tblockMap: { [key: string]: Block }\n): Table {\n\tlet tableMatrix: TableCell[][];\n\ttableMatrix = [];\n\t// visit each of the cell associated with the table's relationship.\n\tfor (const tableRelation of table.Relationships) {\n\t\tfor (const cellId of tableRelation.Ids) {\n\t\t\tconst cellBlock: Block = blockMap[cellId];\n\t\t\tconst row = cellBlock.RowIndex - 1; // textract starts indexing at 1, so subtract it by 1.\n\t\t\tconst col = cellBlock.ColumnIndex - 1; // textract starts indexing at 1, so subtract it by 1.\n\t\t\t// extract data contained inside the cell.\n\t\t\tconst content = extractContentsFromBlock(cellBlock, blockMap);\n\t\t\tconst cell: TableCell = {\n\t\t\t\ttext: content.text,\n\t\t\t\tboundingBox: getBoundingBox(cellBlock.Geometry),\n\t\t\t\tpolygon: getPolygon(cellBlock.Geometry),\n\t\t\t\tselected: content.selected,\n\t\t\t\trowSpan: cellBlock.RowSpan,\n\t\t\t\tcolumnSpan: cellBlock.ColumnSpan,\n\t\t\t};\n\t\t\tif (!tableMatrix[row]) tableMatrix[row] = [];\n\t\t\ttableMatrix[row][col] = cell;\n\t\t}\n\t}\n\tconst rowSize = tableMatrix.length;\n\tconst columnSize = tableMatrix[0].length;\n\t// Note that we leave spanned cells undefined for distinction\n\treturn {\n\t\tsize: { rows: rowSize, columns: columnSize },\n\t\ttable: tableMatrix,\n\t\tboundingBox: getBoundingBox(table.Geometry),\n\t\tpolygon: getPolygon(table.Geometry),\n\t};\n}\n\n/**\n * Constructs a key value object from its children key and value blocks.\n * @param {Block} KeyValue - KeyValue block that has references (`Relationships`) to its children.\n * @param {[id: string]: Block} blockMap - Maps block Ids to blocks.\n */\nexport function constructKeyValue(\n\tkeyBlock: Block,\n\tblockMap: { [key: string]: Block }\n): KeyValue {\n\tlet keyText: string = '';\n\tlet valueText: string = '';\n\tlet valueSelected: boolean;\n\tfor (const keyValueRelation of keyBlock.Relationships) {\n\t\tif (keyValueRelation.Type === 'CHILD') {\n\t\t\t// relation refers to key\n\t\t\tconst contents = extractContentsFromBlock(keyBlock, blockMap);\n\t\t\tkeyText = contents.text;\n\t\t} else if (keyValueRelation.Type === 'VALUE') {\n\t\t\t// relation refers to value\n\t\t\tfor (const valueId of keyValueRelation.Ids) {\n\t\t\t\tconst valueBlock = blockMap[valueId];\n\t\t\t\tconst contents = extractContentsFromBlock(valueBlock, blockMap);\n\t\t\t\tvalueText = contents.text;\n\t\t\t\tif (contents.selected != null) valueSelected = contents.selected;\n\t\t\t}\n\t\t}\n\t}\n\treturn {\n\t\tkey: keyText,\n\t\tvalue: { text: valueText, selected: valueSelected },\n\t\tpolygon: getPolygon(keyBlock.Geometry),\n\t\tboundingBox: getBoundingBox(keyBlock.Geometry),\n\t};\n}\n\n/**\n * Extracts text and selection from input block's children.\n * @param {Block}} block - Block that we want to extract contents from.\n * @param {[id: string]: Block} blockMap - Maps block Ids to blocks.\n */\nexport function extractContentsFromBlock(\n\tblock: Block,\n\tblockMap: { [id: string]: Block }\n): Content {\n\tlet words: string = '';\n\tlet isSelected: boolean;\n\n\tif (!block.Relationships) {\n\t\t// some block might have no content\n\t\treturn { text: '', selected: undefined };\n\t}\n\tfor (const relation of block.Relationships) {\n\t\tfor (const contentId of relation.Ids) {\n\t\t\tconst contentBlock = blockMap[contentId];\n\t\t\tif (contentBlock.BlockType === 'WORD') {\n\t\t\t\twords += contentBlock.Text + ' ';\n\t\t\t} else if (contentBlock.BlockType === 'SELECTION_ELEMENT') {\n\t\t\t\tisSelected = contentBlock.SelectionStatus === 'SELECTED' ? true : false;\n\t\t\t}\n\t\t}\n\t}\n\n\twords = words.substr(0, words.length - 1); // remove trailing space.\n\treturn { text: words, selected: isSelected };\n}\n"]},"metadata":{},"sourceType":"module"}