{"ast":null,"code":"/*\n * Copyright 2017-2017 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\"). You may not use this file except in compliance with\n * the License. A copy of the License is located at\n *\n *     http://aws.amazon.com/apache2.0/\n *\n * or in the \"license\" file accompanying this file. This file is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR\n * CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions\n * and limitations under the License.\n */\nvar __assign = this && this.__assign || function () {\n  __assign = Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n\n      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n    }\n\n    return t;\n  };\n\n  return __assign.apply(this, arguments);\n};\n\nvar __read = this && this.__read || function (o, n) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n  if (!m) return o;\n  var i = m.call(o),\n      r,\n      ar = [],\n      e;\n\n  try {\n    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n  } catch (error) {\n    e = {\n      error: error\n    };\n  } finally {\n    try {\n      if (r && !r.done && (m = i[\"return\"])) m.call(i);\n    } finally {\n      if (e) throw e.error;\n    }\n  }\n\n  return ar;\n};\n\nimport { ConsoleLogger as Logger, Parser } from '@aws-amplify/core';\nimport { AWSS3Provider } from './providers';\nimport axios from 'axios';\nimport { AWSS3UploadTask } from './providers/AWSS3UploadTask';\nvar logger = new Logger('StorageClass');\nvar DEFAULT_PROVIDER = 'AWSS3';\n/**\n * Provide storage methods to use AWS S3\n */\n\nvar Storage =\n/** @class */\nfunction () {\n  /**\n   * Initialize Storage\n   * @param {Object} config - Configuration object for storage\n   */\n  function Storage() {\n    this._config = {};\n    this._pluggables = [];\n    this._cancelTokenSourceMap = new WeakMap();\n    logger.debug('Storage Options', this._config);\n    this.get = this.get.bind(this);\n    this.put = this.put.bind(this);\n    this.remove = this.remove.bind(this);\n    this.list = this.list.bind(this);\n  }\n\n  Storage.prototype.getModuleName = function () {\n    return 'Storage';\n  };\n  /**\n   * add plugin into Storage category\n   * @param {Object} pluggable - an instance of the plugin\n   */\n\n\n  Storage.prototype.addPluggable = function (pluggable) {\n    if (pluggable && pluggable.getCategory() === 'Storage') {\n      this._pluggables.push(pluggable);\n\n      var config = {};\n      config = pluggable.configure(this._config[pluggable.getProviderName()]);\n      return config;\n    }\n  };\n  /**\n   * Get the plugin object\n   * @param providerName - the name of the plugin\n   */\n\n\n  Storage.prototype.getPluggable = function (providerName) {\n    var pluggable = this._pluggables.find(function (pluggable) {\n      return pluggable.getProviderName() === providerName;\n    });\n\n    if (pluggable === undefined) {\n      logger.debug('No plugin found with providerName', providerName);\n      return null;\n    } else return pluggable;\n  };\n  /**\n   * Remove the plugin object\n   * @param providerName - the name of the plugin\n   */\n\n\n  Storage.prototype.removePluggable = function (providerName) {\n    this._pluggables = this._pluggables.filter(function (pluggable) {\n      return pluggable.getProviderName() !== providerName;\n    });\n    return;\n  };\n  /**\n   * Configure Storage\n   * @param {Object} config - Configuration object for storage\n   * @return {Object} - Current configuration\n   */\n\n\n  Storage.prototype.configure = function (config) {\n    var _this = this;\n\n    logger.debug('configure Storage');\n    if (!config) return this._config;\n    var amplifyConfig = Parser.parseMobilehubConfig(config);\n    var storageKeysFromConfig = Object.keys(amplifyConfig.Storage);\n    var storageArrayKeys = ['bucket', 'region', 'level', 'track', 'customPrefix', 'serverSideEncryption', 'SSECustomerAlgorithm', 'SSECustomerKey', 'SSECustomerKeyMD5', 'SSEKMSKeyId'];\n\n    var isInStorageArrayKeys = function (k) {\n      return storageArrayKeys.some(function (x) {\n        return x === k;\n      });\n    };\n\n    var checkConfigKeysFromArray = function (k) {\n      return k.find(function (k) {\n        return isInStorageArrayKeys(k);\n      });\n    };\n\n    if (storageKeysFromConfig && checkConfigKeysFromArray(storageKeysFromConfig) && !amplifyConfig.Storage[DEFAULT_PROVIDER]) {\n      amplifyConfig.Storage[DEFAULT_PROVIDER] = {};\n    }\n\n    Object.entries(amplifyConfig.Storage).map(function (_a) {\n      var _b = __read(_a, 2),\n          key = _b[0],\n          value = _b[1];\n\n      if (key && isInStorageArrayKeys(key) && value !== undefined) {\n        amplifyConfig.Storage[DEFAULT_PROVIDER][key] = value;\n        delete amplifyConfig.Storage[key];\n      }\n    }); // only update new values for each provider\n\n    Object.keys(amplifyConfig.Storage).forEach(function (providerName) {\n      if (typeof amplifyConfig.Storage[providerName] !== 'string') {\n        _this._config[providerName] = __assign(__assign({}, _this._config[providerName]), amplifyConfig.Storage[providerName]);\n      }\n    });\n\n    this._pluggables.forEach(function (pluggable) {\n      pluggable.configure(_this._config[pluggable.getProviderName()]);\n    });\n\n    if (this._pluggables.length === 0) {\n      this.addPluggable(new AWSS3Provider());\n    }\n\n    return this._config;\n  };\n\n  Storage.prototype.getCancellableTokenSource = function () {\n    return axios.CancelToken.source();\n  };\n\n  Storage.prototype.updateRequestToBeCancellable = function (request, cancelTokenSource) {\n    this._cancelTokenSourceMap.set(request, cancelTokenSource);\n  };\n\n  Storage.prototype.isUploadTask = function (x) {\n    return typeof x !== 'undefined' && typeof x['pause'] === 'function' && typeof x['resume'] === 'function';\n  };\n\n  Storage.prototype.cancel = function (request, message) {\n    if (request instanceof AWSS3UploadTask) {\n      return request._cancel();\n    }\n\n    var cancelTokenSource = this._cancelTokenSourceMap.get(request);\n\n    if (cancelTokenSource) {\n      cancelTokenSource.cancel(message);\n    } else {\n      logger.debug('The request does not map to any cancel token');\n    }\n  };\n\n  Storage.prototype.copy = function (src, dest, config) {\n    var provider = (config === null || config === void 0 ? void 0 : config.provider) || DEFAULT_PROVIDER;\n\n    var prov = this._pluggables.find(function (pluggable) {\n      return pluggable.getProviderName() === provider;\n    });\n\n    if (prov === undefined) {\n      logger.debug('No plugin found with providerName', provider);\n      return Promise.reject('No plugin found in Storage for the provider');\n    }\n\n    var cancelTokenSource = this.getCancellableTokenSource();\n\n    if (typeof prov.copy !== 'function') {\n      return Promise.reject(\".copy is not implemented on provider \" + prov.getProviderName());\n    }\n\n    var responsePromise = prov.copy(src, dest, __assign(__assign({}, config), {\n      cancelTokenSource: cancelTokenSource\n    }));\n    this.updateRequestToBeCancellable(responsePromise, cancelTokenSource);\n    return responsePromise;\n  };\n\n  Storage.prototype.get = function (key, config) {\n    var provider = (config === null || config === void 0 ? void 0 : config.provider) || DEFAULT_PROVIDER;\n\n    var prov = this._pluggables.find(function (pluggable) {\n      return pluggable.getProviderName() === provider;\n    });\n\n    if (prov === undefined) {\n      logger.debug('No plugin found with providerName', provider);\n      return Promise.reject('No plugin found in Storage for the provider');\n    }\n\n    var cancelTokenSource = this.getCancellableTokenSource();\n    var responsePromise = prov.get(key, __assign(__assign({}, config), {\n      cancelTokenSource: cancelTokenSource\n    }));\n    this.updateRequestToBeCancellable(responsePromise, cancelTokenSource);\n    return responsePromise;\n  };\n\n  Storage.prototype.isCancelError = function (error) {\n    return axios.isCancel(error);\n  };\n\n  Storage.prototype.put = function (key, object, config) {\n    var provider = (config === null || config === void 0 ? void 0 : config.provider) || DEFAULT_PROVIDER;\n\n    var prov = this._pluggables.find(function (pluggable) {\n      return pluggable.getProviderName() === provider;\n    });\n\n    if (prov === undefined) {\n      logger.debug('No plugin found with providerName', provider);\n      return Promise.reject('No plugin found in Storage for the provider');\n    }\n\n    var cancelTokenSource = this.getCancellableTokenSource();\n    var response = prov.put(key, object, __assign(__assign({}, config), {\n      cancelTokenSource: cancelTokenSource\n    }));\n\n    if (!this.isUploadTask(response)) {\n      this.updateRequestToBeCancellable(response, cancelTokenSource);\n    }\n\n    return response;\n  };\n\n  Storage.prototype.remove = function (key, config) {\n    var provider = (config === null || config === void 0 ? void 0 : config.provider) || DEFAULT_PROVIDER;\n\n    var prov = this._pluggables.find(function (pluggable) {\n      return pluggable.getProviderName() === provider;\n    });\n\n    if (prov === undefined) {\n      logger.debug('No plugin found with providerName', provider);\n      return Promise.reject('No plugin found in Storage for the provider');\n    }\n\n    return prov.remove(key, config);\n  };\n\n  Storage.prototype.list = function (path, config) {\n    var provider = (config === null || config === void 0 ? void 0 : config.provider) || DEFAULT_PROVIDER;\n\n    var prov = this._pluggables.find(function (pluggable) {\n      return pluggable.getProviderName() === provider;\n    });\n\n    if (prov === undefined) {\n      logger.debug('No plugin found with providerName', provider);\n      return Promise.reject('No plugin found in Storage for the provider');\n    }\n\n    return prov.list(path, config);\n  };\n\n  return Storage;\n}();\n\nexport { Storage };\n/**\n * @deprecated use named import\n */\n\nexport default Storage;","map":{"version":3,"mappings":"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","names":["ConsoleLogger","Logger","Parser","AWSS3Provider","axios","AWSS3UploadTask","logger","DEFAULT_PROVIDER","_config","_pluggables","_cancelTokenSourceMap","WeakMap","debug","get","bind","put","remove","list","Storage","pluggable","getCategory","push","config","configure","getProviderName","providerName","find","undefined","filter","amplifyConfig","parseMobilehubConfig","storageKeysFromConfig","Object","keys","storageArrayKeys","isInStorageArrayKeys","k","some","checkConfigKeysFromArray","entries","map","_a","_b","key","value","forEach","_this","__assign","length","addPluggable","CancelToken","source","request","cancelTokenSource","set","x","message","_cancel","cancel","src","dest","provider","prov","Promise","reject","getCancellableTokenSource","copy","responsePromise","updateRequestToBeCancellable","error","isCancel","object","response","isUploadTask","path"],"sources":["C:\\Users\\jacob\\OneDrive\\College\\github\\resumeprojectsrepo\\resumeprojects\\EliteManaging\\node_modules\\@aws-amplify\\storage\\src\\Storage.ts"],"sourcesContent":["/*\n * Copyright 2017-2017 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\"). You may not use this file except in compliance with\n * the License. A copy of the License is located at\n *\n *     http://aws.amazon.com/apache2.0/\n *\n * or in the \"license\" file accompanying this file. This file is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR\n * CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions\n * and limitations under the License.\n */\n\nimport { ConsoleLogger as Logger, Parser } from '@aws-amplify/core';\nimport { AWSS3Provider } from './providers';\nimport {\n\tStorageCopySource,\n\tStorageCopyDestination,\n\tStorageGetConfig,\n\tStorageProvider,\n\tStoragePutConfig,\n\tStorageRemoveConfig,\n\tStorageListConfig,\n\tStorageCopyConfig,\n\tStorageProviderWithCopy,\n\tStorageGetOutput,\n\tStoragePutOutput,\n\tStorageRemoveOutput,\n\tStorageListOutput,\n\tStorageCopyOutput,\n\tUploadTask,\n} from './types';\nimport axios, { CancelTokenSource } from 'axios';\nimport { PutObjectCommandInput } from '@aws-sdk/client-s3';\nimport { AWSS3UploadTask } from './providers/AWSS3UploadTask';\n\nconst logger = new Logger('StorageClass');\n\nconst DEFAULT_PROVIDER = 'AWSS3';\n/**\n * Provide storage methods to use AWS S3\n */\nexport class Storage {\n\t/**\n\t * @private\n\t */\n\tprivate _config;\n\tprivate _pluggables: StorageProvider[];\n\n\t/**\n\t * Similar to the API module. This weak map allows users to cancel their in-flight request made using the Storage\n\t * module. For every get or put request, a unique cancel token will be generated and injected to it's underlying\n\t * AxiosHttpHandler. This map maintains a mapping of Request to CancelTokenSource. When .cancel is invoked, it will\n\t * attempt to retrieve it's corresponding cancelTokenSource and cancel the in-flight request.\n\t */\n\tprivate _cancelTokenSourceMap: WeakMap<Promise<any>, CancelTokenSource>;\n\n\t/**\n\t * @public\n\t */\n\tpublic vault: Storage;\n\n\t/**\n\t * Initialize Storage\n\t * @param {Object} config - Configuration object for storage\n\t */\n\tconstructor() {\n\t\tthis._config = {};\n\t\tthis._pluggables = [];\n\t\tthis._cancelTokenSourceMap = new WeakMap<Promise<any>, CancelTokenSource>();\n\t\tlogger.debug('Storage Options', this._config);\n\n\t\tthis.get = this.get.bind(this);\n\t\tthis.put = this.put.bind(this);\n\t\tthis.remove = this.remove.bind(this);\n\t\tthis.list = this.list.bind(this);\n\t}\n\n\tpublic getModuleName() {\n\t\treturn 'Storage';\n\t}\n\n\t/**\n\t * add plugin into Storage category\n\t * @param {Object} pluggable - an instance of the plugin\n\t */\n\tpublic addPluggable(pluggable: StorageProvider) {\n\t\tif (pluggable && pluggable.getCategory() === 'Storage') {\n\t\t\tthis._pluggables.push(pluggable);\n\t\t\tlet config = {};\n\n\t\t\tconfig = pluggable.configure(this._config[pluggable.getProviderName()]);\n\n\t\t\treturn config;\n\t\t}\n\t}\n\n\t/**\n\t * Get the plugin object\n\t * @param providerName - the name of the plugin\n\t */\n\tpublic getPluggable(providerName: string) {\n\t\tconst pluggable = this._pluggables.find(\n\t\t\tpluggable => pluggable.getProviderName() === providerName\n\t\t);\n\t\tif (pluggable === undefined) {\n\t\t\tlogger.debug('No plugin found with providerName', providerName);\n\t\t\treturn null;\n\t\t} else return pluggable;\n\t}\n\n\t/**\n\t * Remove the plugin object\n\t * @param providerName - the name of the plugin\n\t */\n\tpublic removePluggable(providerName: string) {\n\t\tthis._pluggables = this._pluggables.filter(\n\t\t\tpluggable => pluggable.getProviderName() !== providerName\n\t\t);\n\t\treturn;\n\t}\n\n\t/**\n\t * Configure Storage\n\t * @param {Object} config - Configuration object for storage\n\t * @return {Object} - Current configuration\n\t */\n\tconfigure(config?) {\n\t\tlogger.debug('configure Storage');\n\t\tif (!config) return this._config;\n\n\t\tconst amplifyConfig = Parser.parseMobilehubConfig(config);\n\n\t\tconst storageKeysFromConfig = Object.keys(amplifyConfig.Storage);\n\n\t\tconst storageArrayKeys = [\n\t\t\t'bucket',\n\t\t\t'region',\n\t\t\t'level',\n\t\t\t'track',\n\t\t\t'customPrefix',\n\t\t\t'serverSideEncryption',\n\t\t\t'SSECustomerAlgorithm',\n\t\t\t'SSECustomerKey',\n\t\t\t'SSECustomerKeyMD5',\n\t\t\t'SSEKMSKeyId',\n\t\t];\n\n\t\tconst isInStorageArrayKeys = (k: string) =>\n\t\t\tstorageArrayKeys.some(x => x === k);\n\t\tconst checkConfigKeysFromArray = (k: string[]) =>\n\t\t\tk.find(k => isInStorageArrayKeys(k));\n\n\t\tif (\n\t\t\tstorageKeysFromConfig &&\n\t\t\tcheckConfigKeysFromArray(storageKeysFromConfig) &&\n\t\t\t!amplifyConfig.Storage[DEFAULT_PROVIDER]\n\t\t) {\n\t\t\tamplifyConfig.Storage[DEFAULT_PROVIDER] = {};\n\t\t}\n\n\t\tObject.entries(amplifyConfig.Storage).map(([key, value]) => {\n\t\t\tif (key && isInStorageArrayKeys(key) && value !== undefined) {\n\t\t\t\tamplifyConfig.Storage[DEFAULT_PROVIDER][key] = value;\n\t\t\t\tdelete amplifyConfig.Storage[key];\n\t\t\t}\n\t\t});\n\n\t\t// only update new values for each provider\n\t\tObject.keys(amplifyConfig.Storage).forEach(providerName => {\n\t\t\tif (typeof amplifyConfig.Storage[providerName] !== 'string') {\n\t\t\t\tthis._config[providerName] = {\n\t\t\t\t\t...this._config[providerName],\n\t\t\t\t\t...amplifyConfig.Storage[providerName],\n\t\t\t\t};\n\t\t\t}\n\t\t});\n\n\t\tthis._pluggables.forEach(pluggable => {\n\t\t\tpluggable.configure(this._config[pluggable.getProviderName()]);\n\t\t});\n\n\t\tif (this._pluggables.length === 0) {\n\t\t\tthis.addPluggable(new AWSS3Provider());\n\t\t}\n\n\t\treturn this._config;\n\t}\n\n\tprivate getCancellableTokenSource(): CancelTokenSource {\n\t\treturn axios.CancelToken.source();\n\t}\n\n\tprivate updateRequestToBeCancellable(\n\t\trequest: Promise<any>,\n\t\tcancelTokenSource: CancelTokenSource\n\t) {\n\t\tthis._cancelTokenSourceMap.set(request, cancelTokenSource);\n\t}\n\n\tprivate isUploadTask(x: unknown): x is UploadTask {\n\t\treturn (\n\t\t\ttypeof x !== 'undefined' &&\n\t\t\ttypeof x['pause'] === 'function' &&\n\t\t\ttypeof x['resume'] === 'function'\n\t\t);\n\t}\n\n\t/**\n\t * Cancels an inflight request\n\t *\n\t * @param request - The request to cancel\n\t * @param [message] - A message to include in the cancelation exception\n\t */\n\tpublic cancel(request: UploadTask, message?: string): Promise<boolean>;\n\tpublic cancel(request: Promise<any>, message?: string): void;\n\tpublic cancel(\n\t\trequest: Promise<any> | UploadTask,\n\t\tmessage?: string\n\t): void | Promise<boolean> {\n\t\tif (request instanceof AWSS3UploadTask) {\n\t\t\treturn request._cancel();\n\t\t}\n\t\tconst cancelTokenSource = this._cancelTokenSourceMap.get(\n\t\t\trequest as Promise<any>\n\t\t);\n\t\tif (cancelTokenSource) {\n\t\t\tcancelTokenSource.cancel(message);\n\t\t} else {\n\t\t\tlogger.debug('The request does not map to any cancel token');\n\t\t}\n\t}\n\n\t/**\n\t * Copies a file from src to dest.\n\t *\n\t * @param src - The source object.\n\t * @param dest - The destination object.\n\t * @param [config] - config for the Storage operation.\n\t * @return A promise resolves to the copied object's key.\n\t */\n\tpublic copy<T extends Record<string, any>>(\n\t\tsrc: StorageCopySource,\n\t\tdest: StorageCopyDestination,\n\t\tconfig?: StorageCopyConfig<T>\n\t): StorageCopyOutput<T>;\n\tpublic copy<T extends StorageProviderWithCopy = AWSS3Provider>(\n\t\tsrc: Parameters<T['copy']>[0],\n\t\tdest: Parameters<T['copy']>[1],\n\t\tconfig?: StorageCopyConfig<T>\n\t): StorageCopyOutput<T> {\n\t\tconst provider = config?.provider || DEFAULT_PROVIDER;\n\t\tconst prov = this._pluggables.find(\n\t\t\tpluggable => pluggable.getProviderName() === provider\n\t\t);\n\t\tif (prov === undefined) {\n\t\t\tlogger.debug('No plugin found with providerName', provider);\n\t\t\treturn Promise.reject(\n\t\t\t\t'No plugin found in Storage for the provider'\n\t\t\t) as StorageCopyOutput<T>;\n\t\t}\n\t\tconst cancelTokenSource = this.getCancellableTokenSource();\n\t\tif (typeof prov.copy !== 'function') {\n\t\t\treturn Promise.reject(\n\t\t\t\t`.copy is not implemented on provider ${prov.getProviderName()}`\n\t\t\t) as StorageCopyOutput<T>;\n\t\t}\n\t\tconst responsePromise = prov.copy(src, dest, {\n\t\t\t...config,\n\t\t\tcancelTokenSource,\n\t\t});\n\t\tthis.updateRequestToBeCancellable(responsePromise, cancelTokenSource);\n\t\treturn responsePromise as StorageCopyOutput<T>;\n\t}\n\n\t/**\n\t * Get a presigned URL of the file or the object data when download:true\n\t *\n\t * @param key - key of the object\n\t * @param [config] - config for the Storage operation.\n\t * @return - A promise resolves to either a presigned url or the object\n\t */\n\t// Adding & { download?: boolean }, if not T extends { download: true } ? ... : ... will not work properly\n\tpublic get<T extends Record<string, any> & { download?: boolean }>(\n\t\tkey: string,\n\t\tconfig?: StorageGetConfig<T>\n\t): StorageGetOutput<T>;\n\tpublic get<\n\t\tT extends StorageProvider | { [key: string]: any; download?: boolean }\n\t>(key: string, config?: StorageGetConfig<T>): StorageGetOutput<T> {\n\t\tconst provider = config?.provider || DEFAULT_PROVIDER;\n\t\tconst prov = this._pluggables.find(\n\t\t\tpluggable => pluggable.getProviderName() === provider\n\t\t);\n\t\tif (prov === undefined) {\n\t\t\tlogger.debug('No plugin found with providerName', provider);\n\t\t\treturn Promise.reject(\n\t\t\t\t'No plugin found in Storage for the provider'\n\t\t\t) as StorageGetOutput<T>;\n\t\t}\n\t\tconst cancelTokenSource = this.getCancellableTokenSource();\n\t\tconst responsePromise = prov.get(key, {\n\t\t\t...config,\n\t\t\tcancelTokenSource,\n\t\t});\n\t\tthis.updateRequestToBeCancellable(responsePromise, cancelTokenSource);\n\t\treturn responsePromise as StorageGetOutput<T>;\n\t}\n\n\tpublic isCancelError(error: any) {\n\t\treturn axios.isCancel(error);\n\t}\n\n\t/**\n\t * Put a file in storage bucket specified to configure method\n\t * @param key - key of the object\n\t * @param object - File to be put in bucket\n\t * @param [config] - { level : private|protected|public, contentType: MIME Types,\n\t *  progressCallback: function }\n\t * @return - promise resolves to object on success\n\t */\n\tpublic put<T extends Record<string, any>>(\n\t\tkey: string,\n\t\tobject: any,\n\t\tconfig?: StoragePutConfig<T>\n\t): StoragePutOutput<T>;\n\tpublic put<T extends StorageProvider = AWSS3Provider>(\n\t\tkey: string,\n\t\tobject: Omit<PutObjectCommandInput['Body'], 'ReadableStream' | 'Readable'>,\n\t\tconfig?: StoragePutConfig<T>\n\t): StoragePutOutput<T> {\n\t\tconst provider = config?.provider || DEFAULT_PROVIDER;\n\t\tconst prov = this._pluggables.find(\n\t\t\tpluggable => pluggable.getProviderName() === provider\n\t\t);\n\t\tif (prov === undefined) {\n\t\t\tlogger.debug('No plugin found with providerName', provider);\n\t\t\treturn Promise.reject(\n\t\t\t\t'No plugin found in Storage for the provider'\n\t\t\t) as StoragePutOutput<T>;\n\t\t}\n\t\tconst cancelTokenSource = this.getCancellableTokenSource();\n\t\tconst response = prov.put(key, object, {\n\t\t\t...config,\n\t\t\tcancelTokenSource,\n\t\t});\n\t\tif (!this.isUploadTask(response)) {\n\t\t\tthis.updateRequestToBeCancellable(response, cancelTokenSource);\n\t\t}\n\t\treturn response as StoragePutOutput<T>;\n\t}\n\n\t/**\n\t * Remove the object for specified key\n\t * @param key - key of the object\n\t * @param [config] - { level : private|protected|public }\n\t * @return - Promise resolves upon successful removal of the object\n\t */\n\tpublic remove<T extends Record<string, any>>(\n\t\tkey: string,\n\t\tconfig?: StorageRemoveConfig<T>\n\t): StorageRemoveOutput<T>;\n\tpublic remove<T extends StorageProvider = AWSS3Provider>(\n\t\tkey: string,\n\t\tconfig?: StorageRemoveConfig<T>\n\t): StorageRemoveOutput<T> {\n\t\tconst provider = config?.provider || DEFAULT_PROVIDER;\n\t\tconst prov = this._pluggables.find(\n\t\t\tpluggable => pluggable.getProviderName() === provider\n\t\t);\n\t\tif (prov === undefined) {\n\t\t\tlogger.debug('No plugin found with providerName', provider);\n\t\t\treturn Promise.reject(\n\t\t\t\t'No plugin found in Storage for the provider'\n\t\t\t) as StorageRemoveOutput<T>;\n\t\t}\n\t\treturn prov.remove(key, config) as StorageRemoveOutput<T>;\n\t}\n\n\t/**\n\t * List bucket objects relative to the level and prefix specified\n\t * @param path - the path that contains objects\n\t * @param [config] - { level : private|protected|public, maxKeys: NUMBER }\n\t * @return - Promise resolves to list of keys for all objects in path\n\t */\n\tpublic list<T extends Record<string, any>>(\n\t\tkey: string,\n\t\tconfig?: StorageListConfig<T>\n\t): StorageListOutput<T>;\n\tpublic list<T extends StorageProvider = AWSS3Provider>(\n\t\tpath: string,\n\t\tconfig?: StorageListConfig<T>\n\t): StorageListOutput<T> {\n\t\tconst provider = config?.provider || DEFAULT_PROVIDER;\n\t\tconst prov = this._pluggables.find(\n\t\t\tpluggable => pluggable.getProviderName() === provider\n\t\t);\n\t\tif (prov === undefined) {\n\t\t\tlogger.debug('No plugin found with providerName', provider);\n\t\t\treturn Promise.reject(\n\t\t\t\t'No plugin found in Storage for the provider'\n\t\t\t) as StorageListOutput<T>;\n\t\t}\n\t\treturn prov.list(path, config) as StorageListOutput<T>;\n\t}\n}\n\n/**\n * @deprecated use named import\n */\nexport default Storage;\n"]},"metadata":{},"sourceType":"module"}