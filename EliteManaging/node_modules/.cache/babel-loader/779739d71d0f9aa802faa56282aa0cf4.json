{"ast":null,"code":"import { __assign, __read } from \"tslib\";\nimport { DOT_PATTERN, getArnResources, getSuffix, getSuffixForArnEndpoint, isBucketNameOptions, isDnsCompatibleBucketName, validateAccountId, validateArnEndpointOptions, validateDNSHostLabel, validateNoDualstack, validateNoFIPS, validateOutpostService, validatePartition, validateRegion, validateS3Service, validateService } from \"./bucketHostnameUtils\";\nexport var bucketHostname = function (options) {\n  var isCustomEndpoint = options.isCustomEndpoint,\n      baseHostname = options.baseHostname,\n      dualstackEndpoint = options.dualstackEndpoint,\n      accelerateEndpoint = options.accelerateEndpoint;\n\n  if (isCustomEndpoint) {\n    if (dualstackEndpoint) throw new Error(\"Dualstack endpoint is not supported with custom endpoint\");\n    if (accelerateEndpoint) throw new Error(\"Accelerate endpoint is not supported with custom endpoint\");\n  }\n\n  return isBucketNameOptions(options) ? // Construct endpoint when bucketName is a string referring to a bucket name\n  getEndpointFromBucketName(__assign(__assign({}, options), {\n    isCustomEndpoint: isCustomEndpoint\n  })) : // Construct endpoint when bucketName is an ARN referring to an S3 resource like Access Point\n  getEndpointFromArn(__assign(__assign({}, options), {\n    isCustomEndpoint: isCustomEndpoint\n  }));\n};\n\nvar getEndpointFromArn = function (options) {\n  var isCustomEndpoint = options.isCustomEndpoint,\n      baseHostname = options.baseHostname;\n\n  var _a = __read(isCustomEndpoint ? [options.clientRegion, baseHostname] : // Infer client region and hostname suffix from hostname from endpoints.json, like `s3.us-west-2.amazonaws.com`\n  getSuffixForArnEndpoint(baseHostname), 2),\n      clientRegion = _a[0],\n      hostnameSuffix = _a[1];\n\n  var pathStyleEndpoint = options.pathStyleEndpoint,\n      _b = options.dualstackEndpoint,\n      dualstackEndpoint = _b === void 0 ? false : _b,\n      _c = options.accelerateEndpoint,\n      accelerateEndpoint = _c === void 0 ? false : _c,\n      _d = options.tlsCompatible,\n      tlsCompatible = _d === void 0 ? true : _d,\n      useArnRegion = options.useArnRegion,\n      bucketName = options.bucketName,\n      _e = options.clientPartition,\n      clientPartition = _e === void 0 ? \"aws\" : _e,\n      _f = options.clientSigningRegion,\n      clientSigningRegion = _f === void 0 ? clientRegion : _f;\n  validateArnEndpointOptions({\n    pathStyleEndpoint: pathStyleEndpoint,\n    accelerateEndpoint: accelerateEndpoint,\n    tlsCompatible: tlsCompatible\n  }); // Validate and parse the ARN supplied as a bucket name\n\n  var service = bucketName.service,\n      partition = bucketName.partition,\n      accountId = bucketName.accountId,\n      region = bucketName.region,\n      resource = bucketName.resource;\n  validateService(service);\n  validatePartition(partition, {\n    clientPartition: clientPartition\n  });\n  validateAccountId(accountId);\n  validateRegion(region, {\n    useArnRegion: useArnRegion,\n    clientRegion: clientRegion,\n    clientSigningRegion: clientSigningRegion\n  });\n\n  var _g = getArnResources(resource),\n      accesspointName = _g.accesspointName,\n      outpostId = _g.outpostId;\n\n  validateDNSHostLabel(accesspointName + \"-\" + accountId, {\n    tlsCompatible: tlsCompatible\n  });\n  var endpointRegion = useArnRegion ? region : clientRegion;\n  var signingRegion = useArnRegion ? region : clientSigningRegion;\n\n  if (outpostId) {\n    // if this is an Outpost ARN\n    validateOutpostService(service);\n    validateDNSHostLabel(outpostId, {\n      tlsCompatible: tlsCompatible\n    });\n    validateNoDualstack(dualstackEndpoint);\n    validateNoFIPS(endpointRegion);\n    var hostnamePrefix_1 = accesspointName + \"-\" + accountId + \".\" + outpostId;\n    return {\n      bucketEndpoint: true,\n      hostname: \"\" + hostnamePrefix_1 + (isCustomEndpoint ? \"\" : \".s3-outposts.\" + endpointRegion) + \".\" + hostnameSuffix,\n      signingRegion: signingRegion,\n      signingService: \"s3-outposts\"\n    };\n  } // construct endpoint from Accesspoint ARN\n\n\n  validateS3Service(service);\n  var hostnamePrefix = accesspointName + \"-\" + accountId;\n  return {\n    bucketEndpoint: true,\n    hostname: \"\" + hostnamePrefix + (isCustomEndpoint ? \"\" : \".s3-accesspoint\" + (dualstackEndpoint ? \".dualstack\" : \"\") + \".\" + endpointRegion) + \".\" + hostnameSuffix,\n    signingRegion: signingRegion\n  };\n};\n\nvar getEndpointFromBucketName = function (_a) {\n  var _b = _a.accelerateEndpoint,\n      accelerateEndpoint = _b === void 0 ? false : _b,\n      region = _a.clientRegion,\n      baseHostname = _a.baseHostname,\n      bucketName = _a.bucketName,\n      _c = _a.dualstackEndpoint,\n      dualstackEndpoint = _c === void 0 ? false : _c,\n      _d = _a.pathStyleEndpoint,\n      pathStyleEndpoint = _d === void 0 ? false : _d,\n      _e = _a.tlsCompatible,\n      tlsCompatible = _e === void 0 ? true : _e,\n      _f = _a.isCustomEndpoint,\n      isCustomEndpoint = _f === void 0 ? false : _f;\n\n  var _g = __read(isCustomEndpoint ? [region, baseHostname] : getSuffix(baseHostname), 2),\n      clientRegion = _g[0],\n      hostnameSuffix = _g[1];\n\n  if (pathStyleEndpoint || !isDnsCompatibleBucketName(bucketName) || tlsCompatible && DOT_PATTERN.test(bucketName)) {\n    return {\n      bucketEndpoint: false,\n      hostname: dualstackEndpoint ? \"s3.dualstack.\" + clientRegion + \".\" + hostnameSuffix : baseHostname\n    };\n  }\n\n  if (accelerateEndpoint) {\n    baseHostname = \"s3-accelerate\" + (dualstackEndpoint ? \".dualstack\" : \"\") + \".\" + hostnameSuffix;\n  } else if (dualstackEndpoint) {\n    baseHostname = \"s3.dualstack.\" + clientRegion + \".\" + hostnameSuffix;\n  }\n\n  return {\n    bucketEndpoint: true,\n    hostname: bucketName + \".\" + baseHostname\n  };\n};","map":{"version":3,"mappings":"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","names":["DOT_PATTERN","getArnResources","getSuffix","getSuffixForArnEndpoint","isBucketNameOptions","isDnsCompatibleBucketName","validateAccountId","validateArnEndpointOptions","validateDNSHostLabel","validateNoDualstack","validateNoFIPS","validateOutpostService","validatePartition","validateRegion","validateS3Service","validateService","bucketHostname","options","baseHostname","dualstackEndpoint","accelerateEndpoint","isCustomEndpoint","Error","getEndpointFromBucketName","getEndpointFromArn","clientRegion","hostnameSuffix","_b","_c","_d","tlsCompatible","useArnRegion","bucketName","_e","clientPartition","_f","clientSigningRegion","pathStyleEndpoint","partition","accountId","region","resource","service","accesspointName","outpostId","endpointRegion","signingRegion","hostnamePrefix_1","bucketEndpoint","hostname","signingService","hostnamePrefix","_a","test"],"sources":["C:\\Users\\jacob\\OneDrive\\College\\github\\resumeprojectsrepo\\resumeprojects\\EliteManaging\\node_modules\\@aws-sdk\\middleware-bucket-endpoint\\src\\bucketHostname.ts"],"sourcesContent":["import {\n  ArnHostnameParams,\n  BucketHostnameParams,\n  DOT_PATTERN,\n  getArnResources,\n  getSuffix,\n  getSuffixForArnEndpoint,\n  isBucketNameOptions,\n  isDnsCompatibleBucketName,\n  validateAccountId,\n  validateArnEndpointOptions,\n  validateDNSHostLabel,\n  validateNoDualstack,\n  validateNoFIPS,\n  validateOutpostService,\n  validatePartition,\n  validateRegion,\n  validateS3Service,\n  validateService,\n} from \"./bucketHostnameUtils\";\n\nexport interface BucketHostname {\n  hostname: string;\n  bucketEndpoint: boolean;\n  signingRegion?: string;\n  signingService?: string;\n}\n\nexport const bucketHostname = (options: BucketHostnameParams | ArnHostnameParams): BucketHostname => {\n  const { isCustomEndpoint, baseHostname, dualstackEndpoint, accelerateEndpoint } = options;\n\n  if (isCustomEndpoint) {\n    if (dualstackEndpoint) throw new Error(\"Dualstack endpoint is not supported with custom endpoint\");\n    if (accelerateEndpoint) throw new Error(\"Accelerate endpoint is not supported with custom endpoint\");\n  }\n\n  return isBucketNameOptions(options)\n    ? // Construct endpoint when bucketName is a string referring to a bucket name\n      getEndpointFromBucketName({ ...options, isCustomEndpoint })\n    : // Construct endpoint when bucketName is an ARN referring to an S3 resource like Access Point\n      getEndpointFromArn({ ...options, isCustomEndpoint });\n};\n\nconst getEndpointFromArn = (options: ArnHostnameParams & { isCustomEndpoint: boolean }): BucketHostname => {\n  const { isCustomEndpoint, baseHostname } = options;\n  const [clientRegion, hostnameSuffix] = isCustomEndpoint\n    ? [options.clientRegion, baseHostname]\n    : // Infer client region and hostname suffix from hostname from endpoints.json, like `s3.us-west-2.amazonaws.com`\n      getSuffixForArnEndpoint(baseHostname);\n\n  const {\n    pathStyleEndpoint,\n    dualstackEndpoint = false,\n    accelerateEndpoint = false,\n    tlsCompatible = true,\n    useArnRegion,\n    bucketName,\n    clientPartition = \"aws\",\n    clientSigningRegion = clientRegion,\n  } = options;\n\n  validateArnEndpointOptions({ pathStyleEndpoint, accelerateEndpoint, tlsCompatible });\n\n  // Validate and parse the ARN supplied as a bucket name\n  const { service, partition, accountId, region, resource } = bucketName;\n  validateService(service);\n  validatePartition(partition, { clientPartition });\n  validateAccountId(accountId);\n  validateRegion(region, { useArnRegion, clientRegion, clientSigningRegion });\n  const { accesspointName, outpostId } = getArnResources(resource);\n  validateDNSHostLabel(`${accesspointName}-${accountId}`, { tlsCompatible });\n\n  const endpointRegion = useArnRegion ? region : clientRegion;\n  const signingRegion = useArnRegion ? region : clientSigningRegion;\n  if (outpostId) {\n    // if this is an Outpost ARN\n    validateOutpostService(service);\n    validateDNSHostLabel(outpostId, { tlsCompatible });\n    validateNoDualstack(dualstackEndpoint);\n    validateNoFIPS(endpointRegion);\n    const hostnamePrefix = `${accesspointName}-${accountId}.${outpostId}`;\n    return {\n      bucketEndpoint: true,\n      hostname: `${hostnamePrefix}${isCustomEndpoint ? \"\" : `.s3-outposts.${endpointRegion}`}.${hostnameSuffix}`,\n      signingRegion,\n      signingService: \"s3-outposts\",\n    };\n  }\n  // construct endpoint from Accesspoint ARN\n  validateS3Service(service);\n  const hostnamePrefix = `${accesspointName}-${accountId}`;\n  return {\n    bucketEndpoint: true,\n    hostname: `${hostnamePrefix}${\n      isCustomEndpoint ? \"\" : `.s3-accesspoint${dualstackEndpoint ? \".dualstack\" : \"\"}.${endpointRegion}`\n    }.${hostnameSuffix}`,\n    signingRegion,\n  };\n};\n\nconst getEndpointFromBucketName = ({\n  accelerateEndpoint = false,\n  clientRegion: region,\n  baseHostname,\n  bucketName,\n  dualstackEndpoint = false,\n  pathStyleEndpoint = false,\n  tlsCompatible = true,\n  isCustomEndpoint = false,\n}: BucketHostnameParams & { isCustomEndpoint: boolean }): BucketHostname => {\n  const [clientRegion, hostnameSuffix] = isCustomEndpoint ? [region, baseHostname] : getSuffix(baseHostname);\n  if (pathStyleEndpoint || !isDnsCompatibleBucketName(bucketName) || (tlsCompatible && DOT_PATTERN.test(bucketName))) {\n    return {\n      bucketEndpoint: false,\n      hostname: dualstackEndpoint ? `s3.dualstack.${clientRegion}.${hostnameSuffix}` : baseHostname,\n    };\n  }\n\n  if (accelerateEndpoint) {\n    baseHostname = `s3-accelerate${dualstackEndpoint ? \".dualstack\" : \"\"}.${hostnameSuffix}`;\n  } else if (dualstackEndpoint) {\n    baseHostname = `s3.dualstack.${clientRegion}.${hostnameSuffix}`;\n  }\n\n  return {\n    bucketEndpoint: true,\n    hostname: `${bucketName}.${baseHostname}`,\n  };\n};\n"]},"metadata":{},"sourceType":"module"}